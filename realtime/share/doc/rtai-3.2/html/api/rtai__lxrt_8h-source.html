<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>RTAI API: base/include/rtai_lxrt.h Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.4.2 -->
<div class="qindex">  <form class="search" action="search.php" method="get">
<a class="qindex" href="main.html">Main&nbsp;Page</a> | <a class="qindex" href="modules.html">Modules</a> | <a class="qindex" href="dirs.html">Directories</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="globals.html">Globals</a> | <a class="qindex" href="pages.html">Related&nbsp;Pages</a>  | <span class="search"><u>S</u>earch&nbsp;for&nbsp;<input class="search" type="text" name="query" value="" size="20" accesskey="s"/></span></form></div>
<div class="nav">
<a class="el" href="dir_000000.html">base</a>&nbsp;/&nbsp;<a class="el" href="dir_000014.html">include</a></div>
<h1>rtai_lxrt.h</h1><a href="rtai__lxrt_8h.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment">00001 
00066 <span class="preprocessor">#ifndef _RTAI_LXRT_H</span>
00067 <span class="preprocessor"></span><span class="preprocessor">#define _RTAI_LXRT_H</span>
00068 <span class="preprocessor"></span>
00069 <span class="preprocessor">#include &lt;rtai_sched.h&gt;</span>
00070 <span class="preprocessor">#include &lt;<a class="code" href="rtai__nam2num_8h.html">rtai_nam2num.h</a>&gt;</span>
00071 
00072 <span class="comment">// scheduler</span>
00073 <span class="preprocessor">#define YIELD                            0</span>
00074 <span class="preprocessor"></span><span class="preprocessor">#define SUSPEND                          1</span>
00075 <span class="preprocessor"></span><span class="preprocessor">#define RESUME                           2</span>
00076 <span class="preprocessor"></span><span class="preprocessor">#define MAKE_PERIODIC                    3</span>
00077 <span class="preprocessor"></span><span class="preprocessor">#define WAIT_PERIOD                      4</span>
00078 <span class="preprocessor"></span><span class="preprocessor">#define SLEEP                            5</span>
00079 <span class="preprocessor"></span><span class="preprocessor">#define SLEEP_UNTIL                      6</span>
00080 <span class="preprocessor"></span><span class="preprocessor">#define START_TIMER                      7</span>
00081 <span class="preprocessor"></span><span class="preprocessor">#define STOP_TIMER                       8</span>
00082 <span class="preprocessor"></span><span class="preprocessor">#define GET_TIME                         9</span>
00083 <span class="preprocessor"></span><span class="preprocessor">#define COUNT2NANO                      10</span>
00084 <span class="preprocessor"></span><span class="preprocessor">#define NANO2COUNT                      11</span>
00085 <span class="preprocessor"></span><span class="preprocessor">#define BUSY_SLEEP                      12</span>
00086 <span class="preprocessor"></span><span class="preprocessor">#define SET_PERIODIC_MODE               13</span>
00087 <span class="preprocessor"></span><span class="preprocessor">#define SET_ONESHOT_MODE                14</span>
00088 <span class="preprocessor"></span><span class="preprocessor">#define SIGNAL_HANDLER                  15</span>
00089 <span class="preprocessor"></span><span class="preprocessor">#define TASK_USE_FPU                    16</span>
00090 <span class="preprocessor"></span><span class="preprocessor">#define LINUX_USE_FPU                   17</span>
00091 <span class="preprocessor"></span><span class="preprocessor">#define PREEMPT_ALWAYS_GEN              18</span>
00092 <span class="preprocessor"></span><span class="preprocessor">#define GET_TIME_NS                     19</span>
00093 <span class="preprocessor"></span><span class="preprocessor">#define GET_CPU_TIME_NS                 20</span>
00094 <span class="preprocessor"></span><span class="preprocessor">#define SET_RUNNABLE_ON_CPUS            21 </span>
00095 <span class="preprocessor"></span><span class="preprocessor">#define SET_RUNNABLE_ON_CPUID           22       </span>
00096 <span class="preprocessor"></span><span class="preprocessor">#define GET_TIMER_CPU                   23       </span>
00097 <span class="preprocessor"></span><span class="preprocessor">#define START_RT_APIC_TIMERS            24</span>
00098 <span class="preprocessor"></span><span class="preprocessor">#define PREEMPT_ALWAYS_CPUID            25</span>
00099 <span class="preprocessor"></span><span class="preprocessor">#define COUNT2NANO_CPUID                26</span>
00100 <span class="preprocessor"></span><span class="preprocessor">#define NANO2COUNT_CPUID                27</span>
00101 <span class="preprocessor"></span><span class="preprocessor">#define GET_TIME_CPUID                  28</span>
00102 <span class="preprocessor"></span><span class="preprocessor">#define GET_TIME_NS_CPUID               29</span>
00103 <span class="preprocessor"></span><span class="preprocessor">#define MAKE_PERIODIC_NS                30</span>
00104 <span class="preprocessor"></span><span class="preprocessor">#define SET_SCHED_POLICY                31</span>
00105 <span class="preprocessor"></span><span class="preprocessor">#define SET_RESUME_END                  32</span>
00106 <span class="preprocessor"></span><span class="preprocessor">#define SPV_RMS                         33</span>
00107 <span class="preprocessor"></span><span class="preprocessor">#define WAKEUP_SLEEPING                 34</span>
00108 <span class="preprocessor"></span><span class="preprocessor">#define CHANGE_TASK_PRIO                35</span>
00109 <span class="preprocessor"></span><span class="preprocessor">#define SET_RESUME_TIME                 36</span>
00110 <span class="preprocessor"></span><span class="preprocessor">#define SET_PERIOD                      37</span>
00111 <span class="preprocessor"></span><span class="preprocessor">#define HARD_TIMER_RUNNING              38</span>
00112 <span class="preprocessor"></span>
00113 <span class="comment">// semaphores</span>
00114 <span class="preprocessor">#define TYPED_SEM_INIT                  39</span>
00115 <span class="preprocessor"></span><span class="preprocessor">#define SEM_DELETE                      40</span>
00116 <span class="preprocessor"></span><span class="preprocessor">#define NAMED_SEM_INIT                  41</span>
00117 <span class="preprocessor"></span><span class="preprocessor">#define NAMED_SEM_DELETE                42</span>
00118 <span class="preprocessor"></span><span class="preprocessor">#define SEM_SIGNAL                      43</span>
00119 <span class="preprocessor"></span><span class="preprocessor">#define SEM_WAIT                        44</span>
00120 <span class="preprocessor"></span><span class="preprocessor">#define SEM_WAIT_IF                     45</span>
00121 <span class="preprocessor"></span><span class="preprocessor">#define SEM_WAIT_UNTIL                  46</span>
00122 <span class="preprocessor"></span><span class="preprocessor">#define SEM_WAIT_TIMED                  47</span>
00123 <span class="preprocessor"></span><span class="preprocessor">#define SEM_BROADCAST                   48</span>
00124 <span class="preprocessor"></span><span class="preprocessor">#define SEM_WAIT_BARRIER                49</span>
00125 <span class="preprocessor"></span><span class="preprocessor">#define SEM_COUNT                       50</span>
00126 <span class="preprocessor"></span><span class="preprocessor">#define COND_WAIT                       51</span>
00127 <span class="preprocessor"></span><span class="preprocessor">#define COND_WAIT_UNTIL                 52</span>
00128 <span class="preprocessor"></span><span class="preprocessor">#define COND_WAIT_TIMED                 53</span>
00129 <span class="preprocessor"></span><span class="preprocessor">#define RWL_INIT                        54</span>
00130 <span class="preprocessor"></span><span class="preprocessor">#define RWL_DELETE                      55</span>
00131 <span class="preprocessor"></span><span class="preprocessor">#define NAMED_RWL_INIT                  56</span>
00132 <span class="preprocessor"></span><span class="preprocessor">#define NAMED_RWL_DELETE                57</span>
00133 <span class="preprocessor"></span><span class="preprocessor">#define RWL_RDLOCK                      58</span>
00134 <span class="preprocessor"></span><span class="preprocessor">#define RWL_RDLOCK_IF                   59</span>
00135 <span class="preprocessor"></span><span class="preprocessor">#define RWL_RDLOCK_UNTIL                60</span>
00136 <span class="preprocessor"></span><span class="preprocessor">#define RWL_RDLOCK_TIMED                61</span>
00137 <span class="preprocessor"></span><span class="preprocessor">#define RWL_WRLOCK                      62      </span>
00138 <span class="preprocessor"></span><span class="preprocessor">#define RWL_WRLOCK_IF                   63</span>
00139 <span class="preprocessor"></span><span class="preprocessor">#define RWL_WRLOCK_UNTIL                64</span>
00140 <span class="preprocessor"></span><span class="preprocessor">#define RWL_WRLOCK_TIMED                65</span>
00141 <span class="preprocessor"></span><span class="preprocessor">#define RWL_UNLOCK                      66</span>
00142 <span class="preprocessor"></span><span class="preprocessor">#define SPL_INIT                        67</span>
00143 <span class="preprocessor"></span><span class="preprocessor">#define SPL_DELETE                      68</span>
00144 <span class="preprocessor"></span><span class="preprocessor">#define NAMED_SPL_INIT                  69</span>
00145 <span class="preprocessor"></span><span class="preprocessor">#define NAMED_SPL_DELETE                70</span>
00146 <span class="preprocessor"></span><span class="preprocessor">#define SPL_LOCK                        71      </span>
00147 <span class="preprocessor"></span><span class="preprocessor">#define SPL_LOCK_IF                     72</span>
00148 <span class="preprocessor"></span><span class="preprocessor">#define SPL_LOCK_TIMED                  73</span>
00149 <span class="preprocessor"></span><span class="preprocessor">#define SPL_UNLOCK                      74</span>
00150 <span class="preprocessor"></span>
00151 <span class="comment">// mail boxes</span>
00152 <span class="preprocessor">#define TYPED_MBX_INIT                  75</span>
00153 <span class="preprocessor"></span><span class="preprocessor">#define MBX_DELETE                      76</span>
00154 <span class="preprocessor"></span><span class="preprocessor">#define NAMED_MBX_INIT                  77</span>
00155 <span class="preprocessor"></span><span class="preprocessor">#define NAMED_MBX_DELETE                78</span>
00156 <span class="preprocessor"></span><span class="preprocessor">#define MBX_SEND                        79</span>
00157 <span class="preprocessor"></span><span class="preprocessor">#define MBX_SEND_WP                     80</span>
00158 <span class="preprocessor"></span><span class="preprocessor">#define MBX_SEND_IF                     81</span>
00159 <span class="preprocessor"></span><span class="preprocessor">#define MBX_SEND_UNTIL                  82</span>
00160 <span class="preprocessor"></span><span class="preprocessor">#define MBX_SEND_TIMED                  83</span>
00161 <span class="preprocessor"></span><span class="preprocessor">#define MBX_RECEIVE                     84</span>
00162 <span class="preprocessor"></span><span class="preprocessor">#define MBX_RECEIVE_WP                  85</span>
00163 <span class="preprocessor"></span><span class="preprocessor">#define MBX_RECEIVE_IF                  86</span>
00164 <span class="preprocessor"></span><span class="preprocessor">#define MBX_RECEIVE_UNTIL               87</span>
00165 <span class="preprocessor"></span><span class="preprocessor">#define MBX_RECEIVE_TIMED               88</span>
00166 <span class="preprocessor"></span><span class="preprocessor">#define MBX_EVDRP                       89</span>
00167 <span class="preprocessor"></span><span class="preprocessor">#define MBX_OVRWR_SEND                  90</span>
00168 <span class="preprocessor"></span>
00169 <span class="comment">// short intertask messages</span>
00170 <span class="preprocessor">#define SENDMSG                         91</span>
00171 <span class="preprocessor"></span><span class="preprocessor">#define SEND_IF                         92</span>
00172 <span class="preprocessor"></span><span class="preprocessor">#define SEND_UNTIL                      93</span>
00173 <span class="preprocessor"></span><span class="preprocessor">#define SEND_TIMED                      94</span>
00174 <span class="preprocessor"></span><span class="preprocessor">#define RECEIVEMSG                      95</span>
00175 <span class="preprocessor"></span><span class="preprocessor">#define RECEIVE_IF                      96</span>
00176 <span class="preprocessor"></span><span class="preprocessor">#define RECEIVE_UNTIL                   97</span>
00177 <span class="preprocessor"></span><span class="preprocessor">#define RECEIVE_TIMED                   98</span>
00178 <span class="preprocessor"></span><span class="preprocessor">#define RPCMSG                          99</span>
00179 <span class="preprocessor"></span><span class="preprocessor">#define RPC_IF                         100</span>
00180 <span class="preprocessor"></span><span class="preprocessor">#define RPC_UNTIL                      101</span>
00181 <span class="preprocessor"></span><span class="preprocessor">#define RPC_TIMED                      102</span>
00182 <span class="preprocessor"></span><span class="preprocessor">#define EVDRP                          103</span>
00183 <span class="preprocessor"></span><span class="preprocessor">#define ISRPC                          104</span>
00184 <span class="preprocessor"></span><span class="preprocessor">#define RETURNMSG                      105</span>
00185 <span class="preprocessor"></span>
00186 <span class="comment">// extended intertask messages</span>
00187 <span class="preprocessor">#define RPCX                           106</span>
00188 <span class="preprocessor"></span><span class="preprocessor">#define RPCX_IF                        107</span>
00189 <span class="preprocessor"></span><span class="preprocessor">#define RPCX_UNTIL                     108</span>
00190 <span class="preprocessor"></span><span class="preprocessor">#define RPCX_TIMED                     109</span>
00191 <span class="preprocessor"></span><span class="preprocessor">#define SENDX                          110</span>
00192 <span class="preprocessor"></span><span class="preprocessor">#define SENDX_IF                       111</span>
00193 <span class="preprocessor"></span><span class="preprocessor">#define SENDX_UNTIL                    112</span>
00194 <span class="preprocessor"></span><span class="preprocessor">#define SENDX_TIMED                    113</span>
00195 <span class="preprocessor"></span><span class="preprocessor">#define RETURNX                        114</span>
00196 <span class="preprocessor"></span><span class="preprocessor">#define RECEIVEX                       115</span>
00197 <span class="preprocessor"></span><span class="preprocessor">#define RECEIVEX_IF                    116</span>
00198 <span class="preprocessor"></span><span class="preprocessor">#define RECEIVEX_UNTIL                 117</span>
00199 <span class="preprocessor"></span><span class="preprocessor">#define RECEIVEX_TIMED                 118</span>
00200 <span class="preprocessor"></span><span class="preprocessor">#define EVDRPX                         119</span>
00201 <span class="preprocessor"></span>
00202 <span class="comment">// proxies</span>
00203 <span class="preprocessor">#define PROXY_ATTACH                   120</span>
00204 <span class="preprocessor"></span><span class="preprocessor">#define PROXY_DETACH                   121</span>
00205 <span class="preprocessor"></span><span class="preprocessor">#define PROXY_TRIGGER                  122</span>
00206 <span class="preprocessor"></span>
00207 
00208 <span class="comment">// synchronous user space specific intertask messages and related proxies</span>
00209 <span class="preprocessor">#define RT_SEND                        123</span>
00210 <span class="preprocessor"></span><span class="preprocessor">#define RT_RECEIVE                     124</span>
00211 <span class="preprocessor"></span><span class="preprocessor">#define RT_CRECEIVE                    125</span>
00212 <span class="preprocessor"></span><span class="preprocessor">#define RT_REPLY                       126</span>
00213 <span class="preprocessor"></span><span class="preprocessor">#define RT_PROXY_ATTACH                127</span>
00214 <span class="preprocessor"></span><span class="preprocessor">#define RT_PROXY_DETACH                128</span>
00215 <span class="preprocessor"></span><span class="preprocessor">#define RT_TRIGGER                     129</span>
00216 <span class="preprocessor"></span><span class="preprocessor">#define RT_NAME_ATTACH                 130</span>
00217 <span class="preprocessor"></span><span class="preprocessor">#define RT_NAME_DETACH                 131</span>
00218 <span class="preprocessor"></span><span class="preprocessor">#define RT_NAME_LOCATE                 132</span>
00219 <span class="preprocessor"></span>
00220 <span class="comment">// bits</span>
00221 <span class="preprocessor">#define BITS_INIT                      133      </span>
00222 <span class="preprocessor"></span><span class="preprocessor">#define BITS_DELETE                    134</span>
00223 <span class="preprocessor"></span><span class="preprocessor">#define NAMED_BITS_INIT                135</span>
00224 <span class="preprocessor"></span><span class="preprocessor">#define NAMED_BITS_DELETE              136</span>
00225 <span class="preprocessor"></span><span class="preprocessor">#define BITS_GET                       137</span>
00226 <span class="preprocessor"></span><span class="preprocessor">#define BITS_RESET                     138</span>
00227 <span class="preprocessor"></span><span class="preprocessor">#define BITS_SIGNAL                    139</span>
00228 <span class="preprocessor"></span><span class="preprocessor">#define BITS_WAIT                      140</span>
00229 <span class="preprocessor"></span><span class="preprocessor">#define BITS_WAIT_IF                   141              </span>
00230 <span class="preprocessor"></span><span class="preprocessor">#define BITS_WAIT_UNTIL                142</span>
00231 <span class="preprocessor"></span><span class="preprocessor">#define BITS_WAIT_TIMED                143</span>
00232 <span class="preprocessor"></span>
00233 <span class="comment">// typed mail boxes</span>
00234 <span class="preprocessor">#define TBX_INIT                       144</span>
00235 <span class="preprocessor"></span><span class="preprocessor">#define TBX_DELETE                     145</span>
00236 <span class="preprocessor"></span><span class="preprocessor">#define NAMED_TBX_INIT                 146</span>
00237 <span class="preprocessor"></span><span class="preprocessor">#define NAMED_TBX_DELETE               147</span>
00238 <span class="preprocessor"></span><span class="preprocessor">#define TBX_SEND                       148</span>
00239 <span class="preprocessor"></span><span class="preprocessor">#define TBX_SEND_IF                    149</span>
00240 <span class="preprocessor"></span><span class="preprocessor">#define TBX_SEND_UNTIL                 150</span>
00241 <span class="preprocessor"></span><span class="preprocessor">#define TBX_SEND_TIMED                 151</span>
00242 <span class="preprocessor"></span><span class="preprocessor">#define TBX_RECEIVE                    152</span>
00243 <span class="preprocessor"></span><span class="preprocessor">#define TBX_RECEIVE_IF                 153</span>
00244 <span class="preprocessor"></span><span class="preprocessor">#define TBX_RECEIVE_UNTIL              154</span>
00245 <span class="preprocessor"></span><span class="preprocessor">#define TBX_RECEIVE_TIMED              155</span>
00246 <span class="preprocessor"></span><span class="preprocessor">#define TBX_BROADCAST                  156</span>
00247 <span class="preprocessor"></span><span class="preprocessor">#define TBX_BROADCAST_IF               157</span>
00248 <span class="preprocessor"></span><span class="preprocessor">#define TBX_BROADCAST_UNTIL            158</span>
00249 <span class="preprocessor"></span><span class="preprocessor">#define TBX_BROADCAST_TIMED            159</span>
00250 <span class="preprocessor"></span><span class="preprocessor">#define TBX_URGENT                     160</span>
00251 <span class="preprocessor"></span><span class="preprocessor">#define TBX_URGENT_IF                  161</span>
00252 <span class="preprocessor"></span><span class="preprocessor">#define TBX_URGENT_UNTIL               162</span>
00253 <span class="preprocessor"></span><span class="preprocessor">#define TBX_URGENT_TIMED               163</span>
00254 <span class="preprocessor"></span>
00255 <span class="comment">// pqueue</span>
00256 <span class="preprocessor">#define MQ_OPEN                        164</span>
00257 <span class="preprocessor"></span><span class="preprocessor">#define MQ_RECEIVE                     165</span>
00258 <span class="preprocessor"></span><span class="preprocessor">#define MQ_SEND                        166</span>
00259 <span class="preprocessor"></span><span class="preprocessor">#define MQ_CLOSE                       167</span>
00260 <span class="preprocessor"></span><span class="preprocessor">#define MQ_GETATTR                     168</span>
00261 <span class="preprocessor"></span><span class="preprocessor">#define MQ_SETATTR                     169</span>
00262 <span class="preprocessor"></span><span class="preprocessor">#define MQ_NOTIFY                      170</span>
00263 <span class="preprocessor"></span><span class="preprocessor">#define MQ_UNLINK                      171</span>
00264 <span class="preprocessor"></span><span class="preprocessor">#define MQ_TIMEDRECEIVE                172</span>
00265 <span class="preprocessor"></span><span class="preprocessor">#define MQ_TIMEDSEND                   173</span>
00266 <span class="preprocessor"></span>
00267 <span class="comment">// named tasks init/delete</span>
00268 <span class="preprocessor">#define NAMED_TASK_INIT                174</span>
00269 <span class="preprocessor"></span><span class="preprocessor">#define NAMED_TASK_INIT_CPUID          175</span>
00270 <span class="preprocessor"></span><span class="preprocessor">#define NAMED_TASK_DELETE              176</span>
00271 <span class="preprocessor"></span>
00272 <span class="comment">// registry</span>
00273 <span class="preprocessor">#define GET_ADR                        177</span>
00274 <span class="preprocessor"></span><span class="preprocessor">#define GET_NAME                       178</span>
00275 <span class="preprocessor"></span>
00276 <span class="comment">// netrpc</span>
00277 <span class="preprocessor">#define NETRPC                         179</span>
00278 <span class="preprocessor"></span><span class="preprocessor">#define SEND_REQ_REL_PORT              180</span>
00279 <span class="preprocessor"></span><span class="preprocessor">#define DDN2NL                         181</span>
00280 <span class="preprocessor"></span><span class="preprocessor">#define SET_THIS_NODE                  182</span>
00281 <span class="preprocessor"></span><span class="preprocessor">#define FIND_ASGN_STUB                 183</span>
00282 <span class="preprocessor"></span><span class="preprocessor">#define REL_STUB                       184      </span>
00283 <span class="preprocessor"></span><span class="preprocessor">#define WAITING_RETURN                 185</span>
00284 <span class="preprocessor"></span>
00285 <span class="comment">// a semaphore extension</span>
00286 <span class="preprocessor">#define COND_SIGNAL                    186</span>
00287 <span class="preprocessor"></span>
00288 <span class="comment">// new shm</span>
00289 <span class="preprocessor">#define SHM_ALLOC                      187</span>
00290 <span class="preprocessor"></span><span class="preprocessor">#define SHM_FREE                       188</span>
00291 <span class="preprocessor"></span><span class="preprocessor">#define SHM_SIZE                       189</span>
00292 <span class="preprocessor"></span><span class="preprocessor">#define HEAP_SET                       190</span>
00293 <span class="preprocessor"></span><span class="preprocessor">#define HEAP_ALLOC                     191</span>
00294 <span class="preprocessor"></span><span class="preprocessor">#define HEAP_FREE                      192</span>
00295 <span class="preprocessor"></span><span class="preprocessor">#define HEAP_NAMED_ALLOC               193</span>
00296 <span class="preprocessor"></span><span class="preprocessor">#define HEAP_NAMED_FREE                194</span>
00297 <span class="preprocessor"></span><span class="preprocessor">#define MALLOC                         195</span>
00298 <span class="preprocessor"></span><span class="preprocessor">#define FREE                           196</span>
00299 <span class="preprocessor"></span><span class="preprocessor">#define NAMED_MALLOC                   197</span>
00300 <span class="preprocessor"></span><span class="preprocessor">#define NAMED_FREE                     198</span>
00301 <span class="preprocessor"></span>
00302 <span class="preprocessor">#define SUSPEND_IF                     199</span>
00303 <span class="preprocessor"></span><span class="preprocessor">#define SUSPEND_UNTIL                  200</span>
00304 <span class="preprocessor"></span><span class="preprocessor">#define SUSPEND_TIMED                  201</span>
00305 <span class="preprocessor"></span><span class="preprocessor">#define IRQ_WAIT                       202      </span>
00306 <span class="preprocessor"></span><span class="preprocessor">#define IRQ_WAIT_IF                    203      </span>
00307 <span class="preprocessor"></span><span class="preprocessor">#define IRQ_WAIT_UNTIL                 204</span>
00308 <span class="preprocessor"></span><span class="preprocessor">#define IRQ_WAIT_TIMED                 205</span>
00309 <span class="preprocessor"></span><span class="preprocessor">#define IRQ_SIGNAL                     206</span>
00310 <span class="preprocessor"></span><span class="preprocessor">#define REQUEST_IRQ_TASK               207</span>
00311 <span class="preprocessor"></span><span class="preprocessor">#define RELEASE_IRQ_TASK               208</span>
00312 <span class="preprocessor"></span><span class="preprocessor">#define SCHED_LOCK                     209</span>
00313 <span class="preprocessor"></span><span class="preprocessor">#define SCHED_UNLOCK                   210</span>
00314 <span class="preprocessor"></span><span class="preprocessor">#define PEND_LINUX_IRQ                 211</span>
00315 <span class="preprocessor"></span><span class="preprocessor">#define RECEIVE_LINUX_SYSCALL          212</span>
00316 <span class="preprocessor"></span><span class="preprocessor">#define RETURN_LINUX_SYSCALL           213</span>
00317 <span class="preprocessor"></span>
00318 <span class="preprocessor">#define MAX_LXRT_FUN                   215</span>
00319 <span class="preprocessor"></span>
00320 <span class="comment">// not recovered yet </span>
00321 <span class="comment">// Qblk's </span>
00322 <span class="preprocessor">#define RT_INITTICKQUEUE                69</span>
00323 <span class="preprocessor"></span><span class="preprocessor">#define RT_RELEASETICKQUEUE             70</span>
00324 <span class="preprocessor"></span><span class="preprocessor">#define RT_QDYNALLOC                    71</span>
00325 <span class="preprocessor"></span><span class="preprocessor">#define RT_QDYNFREE                     72</span>
00326 <span class="preprocessor"></span><span class="preprocessor">#define RT_QDYNINIT                     73</span>
00327 <span class="preprocessor"></span><span class="preprocessor">#define RT_QBLKWAIT                     74</span>
00328 <span class="preprocessor"></span><span class="preprocessor">#define RT_QBLKREPEAT                   75</span>
00329 <span class="preprocessor"></span><span class="preprocessor">#define RT_QBLKSOON                     76</span>
00330 <span class="preprocessor"></span><span class="preprocessor">#define RT_QBLKDEQUEUE                  77</span>
00331 <span class="preprocessor"></span><span class="preprocessor">#define RT_QBLKCANCEL                   78</span>
00332 <span class="preprocessor"></span><span class="preprocessor">#define RT_QSYNC                        79</span>
00333 <span class="preprocessor"></span><span class="preprocessor">#define RT_QRECEIVE                     80</span>
00334 <span class="preprocessor"></span><span class="preprocessor">#define RT_QLOOP                        81</span>
00335 <span class="preprocessor"></span><span class="preprocessor">#define RT_QSTEP                        82</span>
00336 <span class="preprocessor"></span><span class="preprocessor">#define RT_QBLKBEFORE                   83</span>
00337 <span class="preprocessor"></span><span class="preprocessor">#define RT_QBLKAFTER                    84</span>
00338 <span class="preprocessor"></span><span class="preprocessor">#define RT_QBLKUNHOOK                   85</span>
00339 <span class="preprocessor"></span><span class="preprocessor">#define RT_QBLKRELEASE                  86</span>
00340 <span class="preprocessor"></span><span class="preprocessor">#define RT_QBLKCOMPLETE                 87</span>
00341 <span class="preprocessor"></span><span class="preprocessor">#define RT_QHOOKFLUSH                   88</span>
00342 <span class="preprocessor"></span><span class="preprocessor">#define RT_QBLKATHEAD                   89</span>
00343 <span class="preprocessor"></span><span class="preprocessor">#define RT_QBLKATTAIL                   90</span>
00344 <span class="preprocessor"></span><span class="preprocessor">#define RT_QHOOKINIT                    91</span>
00345 <span class="preprocessor"></span><span class="preprocessor">#define RT_QHOOKRELEASE                 92</span>
00346 <span class="preprocessor"></span><span class="preprocessor">#define RT_QBLKSCHEDULE                 93</span>
00347 <span class="preprocessor"></span><span class="preprocessor">#define RT_GETTICKQUEUEHOOK             94</span>
00348 <span class="preprocessor"></span><span class="comment">// Testing</span>
00349 <span class="preprocessor">#define RT_BOOM                         95</span>
00350 <span class="preprocessor"></span><span class="preprocessor">#define RTAI_MALLOC                     96</span>
00351 <span class="preprocessor"></span><span class="preprocessor">#define RT_FREE                         97</span>
00352 <span class="preprocessor"></span><span class="preprocessor">#define RT_MMGR_STATS                   98</span>
00353 <span class="preprocessor"></span><span class="preprocessor">#define RT_STOMP                        99</span>
00354 <span class="preprocessor"></span><span class="comment">// VC</span>
00355 <span class="preprocessor">#define RT_VC_ATTACH                    100</span>
00356 <span class="preprocessor"></span><span class="preprocessor">#define RT_VC_RELEASE                   101</span>
00357 <span class="preprocessor"></span><span class="preprocessor">#define RT_VC_RESERVE                   102</span>
00358 <span class="preprocessor"></span><span class="comment">// Linux Signal Support</span>
00359 <span class="preprocessor">#define RT_GET_LINUX_SIGNAL             103</span>
00360 <span class="preprocessor"></span><span class="preprocessor">#define RT_GET_ERRNO                    104</span>
00361 <span class="preprocessor"></span><span class="preprocessor">#define RT_SET_LINUX_SIGNAL_HANDLER     105</span>
00362 <span class="preprocessor"></span><span class="comment">// end of not recovered yet</span>
00363 
00364 <span class="preprocessor">#define LXRT_GET_ADR            1000</span>
00365 <span class="preprocessor"></span><span class="preprocessor">#define LXRT_GET_NAME           1001</span>
00366 <span class="preprocessor"></span><span class="preprocessor">#define LXRT_TASK_INIT          1002</span>
00367 <span class="preprocessor"></span><span class="preprocessor">#define LXRT_TASK_DELETE        1003</span>
00368 <span class="preprocessor"></span><span class="preprocessor">#define LXRT_SEM_INIT           1004</span>
00369 <span class="preprocessor"></span><span class="preprocessor">#define LXRT_SEM_DELETE         1005</span>
00370 <span class="preprocessor"></span><span class="preprocessor">#define LXRT_MBX_INIT           1006</span>
00371 <span class="preprocessor"></span><span class="preprocessor">#define LXRT_MBX_DELETE         1007</span>
00372 <span class="preprocessor"></span><span class="preprocessor">#define MAKE_SOFT_RT            1008</span>
00373 <span class="preprocessor"></span><span class="preprocessor">#define MAKE_HARD_RT            1009</span>
00374 <span class="preprocessor"></span><span class="preprocessor">#define PRINT_TO_SCREEN         1010</span>
00375 <span class="preprocessor"></span><span class="preprocessor">#define NONROOT_HRT             1011</span>
00376 <span class="preprocessor"></span><span class="preprocessor">#define RT_BUDDY                1012</span>
00377 <span class="preprocessor"></span><span class="preprocessor">#define HRT_USE_FPU             1013</span>
00378 <span class="preprocessor"></span><span class="preprocessor">#define USP_SIGHDL              1014</span>
00379 <span class="preprocessor"></span><span class="preprocessor">#define GET_USP_FLAGS           1015</span>
00380 <span class="preprocessor"></span><span class="preprocessor">#define SET_USP_FLAGS           1016</span>
00381 <span class="preprocessor"></span><span class="preprocessor">#define GET_USP_FLG_MSK         1017</span>
00382 <span class="preprocessor"></span><span class="preprocessor">#define SET_USP_FLG_MSK         1018</span>
00383 <span class="preprocessor"></span><span class="preprocessor">#define IS_HARD                 1019</span>
00384 <span class="preprocessor"></span><span class="preprocessor">#define LINUX_SERVER_INIT       1020</span>
00385 <span class="preprocessor"></span><span class="preprocessor">#define ALLOC_REGISTER          1021</span>
00386 <span class="preprocessor"></span><span class="preprocessor">#define DELETE_DEREGISTER       1022</span>
00387 <span class="preprocessor"></span><span class="preprocessor">#define FORCE_TASK_SOFT         1023</span>
00388 <span class="preprocessor"></span><span class="preprocessor">#define PRINTK                  1024</span>
00389 <span class="preprocessor"></span><span class="preprocessor">#define GET_EXECTIME            1025</span>
00390 <span class="preprocessor"></span><span class="preprocessor">#define GET_TIMEORIG            1026</span>
00391 <span class="preprocessor"></span><span class="preprocessor">#define LXRT_RWL_INIT           1027</span>
00392 <span class="preprocessor"></span><span class="preprocessor">#define LXRT_RWL_DELETE         1028</span>
00393 <span class="preprocessor"></span><span class="preprocessor">#define LXRT_SPL_INIT           1029</span>
00394 <span class="preprocessor"></span><span class="preprocessor">#define LXRT_SPL_DELETE         1030</span>
00395 <span class="preprocessor"></span>
00396 <span class="preprocessor">#define FORCE_SOFT 0x80000000</span>
00397 <span class="preprocessor"></span>
00398 <span class="comment">// Keep LXRT call enc/decoding together, so you are sure to act consistently.</span>
00399 <span class="comment">// This is the encoding, note " | GT_NR_SYSCALLS" to ensure not a Linux syscall, ...</span>
00400 <span class="preprocessor">#define GT_NR_SYSCALLS  (1 &lt;&lt; 15)</span>
00401 <span class="preprocessor"></span><span class="preprocessor">#define ENCODE_LXRT_REQ(dynx, srq, lsize)  (((dynx) &lt;&lt; 28) | (((srq) &amp; 0xFFF) &lt;&lt; 16) | GT_NR_SYSCALLS | (lsize))</span>
00402 <span class="preprocessor"></span><span class="comment">// ... and this is the decoding.</span>
00403 <span class="preprocessor">#define SRQ(x)   (((x) &gt;&gt; 16) &amp; 0xFFF)</span>
00404 <span class="preprocessor"></span><span class="preprocessor">#define NARG(x)  ((x) &amp; (GT_NR_SYSCALLS - 1))</span>
00405 <span class="preprocessor"></span><span class="preprocessor">#define INDX(x)  (((x) &gt;&gt; 28) &amp; 0xF)</span>
00406 <span class="preprocessor"></span>
00407 <span class="preprocessor">#ifdef __KERNEL__</span>
00408 <span class="preprocessor"></span>
00409 <span class="preprocessor">#include &lt;asm/rtai_lxrt.h&gt;</span>
00410 
00411 <span class="comment">/*</span>
00412 <span class="comment">     Encoding of system call argument</span>
00413 <span class="comment">            31                                    0  </span>
00414 <span class="comment">soft SRQ    .... |||| |||| |||| .... .... .... ....  0 - 4095 max</span>
00415 <span class="comment">int  NARG   .... .... .... .... |||| |||| |||| ||||  </span>
00416 <span class="comment">arg  INDX   |||| .... .... .... .... .... .... ....</span>
00417 <span class="comment">*/</span>
00418 
00419 <span class="comment">/*</span>
00420 <span class="comment">These USP (unsigned long long) type fields allow to read and write up to 2 arguments.  </span>
00421 <span class="comment">                                               </span>
00422 <span class="comment">RW marker .... .... .... .... .... .... .... ..|| .... .... .... .... .... .... .... ...|</span>
00423 <span class="comment"></span>
00424 <span class="comment">HIGH unsigned long encodes writes</span>
00425 <span class="comment">W ARG1 BF .... .... .... .... .... ...| |||| ||..</span>
00426 <span class="comment">W ARG1 SZ .... .... .... .... |||| |||. .... ....</span>
00427 <span class="comment">W ARG2 BF .... .... .||| |||| .... .... .... ....</span>
00428 <span class="comment">W ARG2 SZ ..|| |||| |... .... .... .... .... ....</span>
00429 <span class="comment">W 1st  LL .|.. .... .... .... .... .... .... ....</span>
00430 <span class="comment">W 2nd  LL |... .... .... .... .... .... .... ....</span>
00431 <span class="comment"></span>
00432 <span class="comment">LOW unsigned long encodes reads</span>
00433 <span class="comment">R ARG1 BF .... .... .... .... .... ...| |||| ||..</span>
00434 <span class="comment">R ARG1 SZ .... .... .... .... |||| |||. .... ....</span>
00435 <span class="comment">R ARG2 BF .... .... .||| |||| .... .... .... ....</span>
00436 <span class="comment">R ARG2 SZ ..|| |||| |... .... .... .... .... ....</span>
00437 <span class="comment">R 1st  LL .|.. .... .... .... .... .... .... ....</span>
00438 <span class="comment">R 2nd  LL |... .... .... .... .... .... .... ....</span>
00439 <span class="comment"></span>
00440 <span class="comment">LOW unsigned long encodes also</span>
00441 <span class="comment">RT Switch .... .... .... .... .... .... .... ...|</span>
00442 <span class="comment"></span>
00443 <span class="comment">and </span>
00444 <span class="comment">Always 0  .... .... .... .... .... .... .... ..|.</span>
00445 <span class="comment"></span>
00446 <span class="comment">If SZ is zero sizeof(int) is copied by default, if LL bit is set sizeof(long long) is copied.</span>
00447 <span class="comment">*/</span>
00448 
00449 <span class="comment">// These are for setting appropriate bits in any function entry structure, OR</span>
00450 <span class="comment">// them in fun entry type to obtain the desired encoding</span>
00451 
00452 <span class="comment">// for writes</span>
00453 <span class="preprocessor">#define UW1(bf, sz)  ((((unsigned long long)((((bf) &amp; 0x7F) &lt;&lt;  2) | (((sz) &amp; 0x7F) &lt;&lt;  9))) &lt;&lt; 32) | 0x300000001LL)</span>
00454 <span class="preprocessor"></span><span class="preprocessor">#define UW2(bf, sz)  ((((unsigned long long)((((bf) &amp; 0x7F) &lt;&lt; 16) | (((sz) &amp; 0x7F) &lt;&lt; 23))) &lt;&lt; 32) | 0x300000001LL)</span>
00455 <span class="preprocessor"></span><span class="preprocessor">#define UWSZ1LL      (0x4000000300000001LL)</span>
00456 <span class="preprocessor"></span><span class="preprocessor">#define UWSZ2LL      (0x8000000300000001LL)</span>
00457 <span class="preprocessor"></span>
00458 <span class="comment">// for reads</span>
00459 <span class="preprocessor">#define UR1(bf, sz)  ((((bf) &amp; 0x7F) &lt;&lt;  2) | (((sz) &amp; 0x7F) &lt;&lt;  9) | 0x300000001LL)</span>
00460 <span class="preprocessor"></span><span class="preprocessor">#define UR2(bf, sz)  ((((bf) &amp; 0x7F) &lt;&lt; 16) | (((sz) &amp; 0x7F) &lt;&lt; 23) | 0x300000001LL)</span>
00461 <span class="preprocessor"></span><span class="preprocessor">#define URSZ1LL      (0x340000001LL)</span>
00462 <span class="preprocessor"></span><span class="preprocessor">#define URSZ2LL      (0x380000001LL)</span>
00463 <span class="preprocessor"></span>
00464 <span class="comment">// and these are for deciding what to do in lxrt.c</span>
00465 <span class="preprocessor">#define NEED_TO_RW(x)   (((unsigned long *)&amp;(x))[HIGH])</span>
00466 <span class="preprocessor"></span>
00467 <span class="preprocessor">#define NEED_TO_R(x)    (((unsigned long *)&amp;(x))[LOW]  &amp; 0x0000FFFC)</span>
00468 <span class="preprocessor"></span><span class="preprocessor">#define NEED_TO_W(x)    (((unsigned long *)&amp;(x))[HIGH] &amp; 0x0000FFFC)</span>
00469 <span class="preprocessor"></span>
00470 <span class="preprocessor">#define NEED_TO_R2ND(x) (((unsigned long *)&amp;(x))[LOW]  &amp; 0x3FFF0000)</span>
00471 <span class="preprocessor"></span><span class="preprocessor">#define NEED_TO_W2ND(x) (((unsigned long *)&amp;(x))[HIGH] &amp; 0x3FFF0000)</span>
00472 <span class="preprocessor"></span>
00473 <span class="preprocessor">#define USP_RBF1(x)     ((((unsigned long *)&amp;(x))[LOW] &gt;&gt;  2) &amp; 0x7F)</span>
00474 <span class="preprocessor"></span><span class="preprocessor">#define USP_RSZ1(x)     ((((unsigned long *)&amp;(x))[LOW] &gt;&gt;  9) &amp; 0x7F)</span>
00475 <span class="preprocessor"></span><span class="preprocessor">#define USP_RBF2(x)     ((((unsigned long *)&amp;(x))[LOW] &gt;&gt; 16) &amp; 0x7F)</span>
00476 <span class="preprocessor"></span><span class="preprocessor">#define USP_RSZ2(x)     ((((unsigned long *)&amp;(x))[LOW] &gt;&gt; 23) &amp; 0x7F)</span>
00477 <span class="preprocessor"></span><span class="preprocessor">#define USP_RSZ1LL(x)   (((unsigned long *)&amp;(x))[LOW] &amp; 0x40000000)</span>
00478 <span class="preprocessor"></span><span class="preprocessor">#define USP_RSZ2LL(x)   (((unsigned long *)&amp;(x))[LOW] &amp; 0x80000000)</span>
00479 <span class="preprocessor"></span>
00480 <span class="preprocessor">#define USP_WBF1(x)     ((((unsigned long *)&amp;(x))[HIGH] &gt;&gt;  2) &amp; 0x7F)</span>
00481 <span class="preprocessor"></span><span class="preprocessor">#define USP_WSZ1(x)     ((((unsigned long *)&amp;(x))[HIGH] &gt;&gt;  9) &amp; 0x7F)</span>
00482 <span class="preprocessor"></span><span class="preprocessor">#define USP_WBF2(x)     ((((unsigned long *)&amp;(x))[HIGH] &gt;&gt; 16) &amp; 0x7F)</span>
00483 <span class="preprocessor"></span><span class="preprocessor">#define USP_WSZ2(x)     ((((unsigned long *)&amp;(x))[HIGH] &gt;&gt; 23) &amp; 0x7F)</span>
00484 <span class="preprocessor"></span><span class="preprocessor">#define USP_WSZ1LL(x)   (((unsigned long *)&amp;(x))[HIGH] &amp; 0x40000000)</span>
00485 <span class="preprocessor"></span><span class="preprocessor">#define USP_WSZ2LL(x)   (((unsigned long *)&amp;(x))[HIGH] &amp; 0x80000000)</span>
00486 <span class="preprocessor"></span>
00487 <span class="keyword">struct </span>rt_fun_entry {
00488     <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> <span class="keywordtype">long</span> type;
00489     <span class="keywordtype">void</span> *fun;
00490 };
00491 
00492 <span class="keyword">struct </span>rt_native_fun_entry {
00493     <span class="keyword">struct </span>rt_fun_entry fun;
00494     <span class="keywordtype">int</span> index;
00495 };
00496 
00497 <span class="keyword">extern</span> <span class="keyword">struct </span>rt_fun_entry rt_fun_lxrt[];
00498 
00499 <span class="keywordtype">void</span> reset_rt_fun_entries(<span class="keyword">struct</span> rt_native_fun_entry *entry);
00500 
00501 <span class="keywordtype">int</span> set_rt_fun_entries(<span class="keyword">struct</span> rt_native_fun_entry *entry);
00502 
00503 <span class="preprocessor">#ifdef __cplusplus</span>
00504 <span class="preprocessor"></span><span class="keyword">extern</span> <span class="stringliteral">"C"</span> {
00505 <span class="preprocessor">#endif </span><span class="comment">/* __cplusplus */</span>
00506 
00507 <span class="preprocessor">#if CONFIG_RTAI_INTERNAL_LXRT_SUPPORT</span>
00508 <span class="preprocessor"></span> 
00509 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">struct </span>rt_task_struct *pid2rttask(pid_t pid)
00510 {
00511         <span class="keywordflow">return</span> ((<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span>)pid) &gt; PID_MAX_LIMIT ? (<span class="keyword">struct </span>rt_task_struct *)pid : find_task_by_pid(pid)-&gt;rtai_tskext(0);
00512 }
00513 
00514 <span class="keyword">static</span> <span class="keyword">inline</span> pid_t rttask2pid(<span class="keyword">struct</span> rt_task_struct * task)
00515 {
00516     <span class="keywordflow">return</span> task-&gt;lnxtsk ? task-&gt;lnxtsk-&gt;pid : (int) task;
00517 }
00518 
00519 <span class="preprocessor">#else </span><span class="comment">/* !CONFIG_RTAI_INTERNAL_LXRT_SUPPORT */</span>
00520 
00521 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">struct </span>rt_task_struct *pid2rttask(pid_t pid)
00522 {
00523     <span class="keywordflow">return</span> 0;
00524 }
00525 
00526 <span class="comment">// The following might look strange but it must be so to work with</span>
00527 <span class="comment">// buddies also.</span>
00528 <span class="keyword">static</span> <span class="keyword">inline</span> pid_t rttask2pid(<span class="keyword">struct</span> rt_task_struct * task)
00529 {
00530     <span class="keywordflow">return</span> (<span class="keywordtype">int</span>) task;
00531 }
00532 
00533 <span class="preprocessor">#endif </span><span class="comment">/* CONFIG_RTAI_INTERNAL_LXRT_SUPPORT */</span>
00534 
00535 <span class="keywordtype">int</span> set_rtai_callback(<span class="keywordtype">void</span> (*fun)(<span class="keywordtype">void</span>));
00536 
00537 <span class="keywordtype">void</span> remove_rtai_callback(<span class="keywordtype">void</span> (*fun)(<span class="keywordtype">void</span>));
00538 
00539 RT_TASK *rt_lxrt_whoami(<span class="keywordtype">void</span>);
00540 
00541 <span class="keywordtype">void</span> exec_func(<span class="keywordtype">void</span> (*func)(<span class="keywordtype">void</span> *data, <span class="keywordtype">int</span> evn),
00542                <span class="keywordtype">void</span> *data,
00543                <span class="keywordtype">int</span> evn);
00544 
00545 <span class="keywordtype">int</span>  set_rt_fun_ext_index(<span class="keyword">struct</span> rt_fun_entry *fun,
00546                           <span class="keywordtype">int</span> idx);
00547 
00548 <span class="keywordtype">void</span> reset_rt_fun_ext_index(<span class="keyword">struct</span> rt_fun_entry *fun,
00549                             <span class="keywordtype">int</span> idx);
00550 
00551 <span class="preprocessor">#ifdef __cplusplus</span>
00552 <span class="preprocessor"></span>}
00553 <span class="preprocessor">#endif </span><span class="comment">/* __cplusplus */</span>
00554 
00555 <span class="preprocessor">#else </span><span class="comment">/* !__KERNEL__ */</span>
00556 
00557 <span class="preprocessor">#include &lt;sys/types.h&gt;</span>
00558 <span class="preprocessor">#include &lt;sched.h&gt;</span>
00559 <span class="preprocessor">#include &lt;stdarg.h&gt;</span>
00560 <span class="preprocessor">#include &lt;stdio.h&gt;</span>
00561 <span class="preprocessor">#include &lt;string.h&gt;</span>
00562 <span class="preprocessor">#include &lt;asm/rtai_lxrt.h&gt;</span>
00563 
00564 <span class="keyword">struct </span>apic_timer_setup_data;
00565 
00566 <span class="preprocessor">#define rt_grow_and_lock_stack(incr) \</span>
00567 <span class="preprocessor">        do { \</span>
00568 <span class="preprocessor">                char buf[incr]; \</span>
00569 <span class="preprocessor">                memset(buf, 0, incr); \</span>
00570 <span class="preprocessor">                mlockall(MCL_CURRENT | MCL_FUTURE); \</span>
00571 <span class="preprocessor">        } while (0)</span>
00572 <span class="preprocessor"></span>
00573 <span class="preprocessor">#define BIDX   0 // rt_fun_ext[0]</span>
00574 <span class="preprocessor"></span><span class="preprocessor">#define SIZARG sizeof(arg)</span>
00575 <span class="preprocessor"></span>
00576 <span class="preprocessor">#ifdef __cplusplus</span>
00577 <span class="preprocessor"></span><span class="keyword">extern</span> <span class="stringliteral">"C"</span> {
00578 <span class="preprocessor">#endif </span><span class="comment">/* __cplusplus */</span>
00579 
<a name="l00587"></a><a class="code" href="group__lxrt.html#ga0">00587</a> RTAI_PROTO(<span class="keywordtype">void</span> *,<a class="code" href="group__lxrt.html#ga0">rt_get_adr</a>,(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> name))
00588 {
00589         <span class="keyword">struct </span>{ <span class="keywordtype">int</span> name; } arg = { name };
00590         <span class="keywordflow">return</span> rtai_lxrt(BIDX, SIZARG, LXRT_GET_ADR, &amp;arg).v[LOW];
00591 } 
00592 
<a name="l00601"></a><a class="code" href="group__lxrt.html#ga1">00601</a> RTAI_PROTO(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span>,<a class="code" href="group__lxrt.html#ga1">rt_get_name</a>,(<span class="keywordtype">void</span> *adr))
00602 {
00603         <span class="keyword">struct </span>{ <span class="keywordtype">void</span> *adr; } arg = { adr };
00604         <span class="keywordflow">return</span> rtai_lxrt(BIDX, SIZARG, LXRT_GET_NAME, &amp;arg).i[LOW];
00605 }
00606 
00607 RTAI_PROTO(RT_TASK *,rt_task_init_schmod,(<span class="keywordtype">int</span> name, <span class="keywordtype">int</span> priority, <span class="keywordtype">int</span> stack_size, <span class="keywordtype">int</span> max_msg_size, <span class="keywordtype">int</span> policy, <span class="keywordtype">int</span> cpus_allowed))
00608 {
00609         <span class="keyword">struct </span>sched_param mysched;
00610         <span class="keyword">struct </span>{ <span class="keywordtype">int</span> name, priority, stack_size, max_msg_size, cpus_allowed; } arg = { name, priority, stack_size, max_msg_size, cpus_allowed };
00611 
00612         mysched.sched_priority = sched_get_priority_max(policy) - priority;
00613         <span class="keywordflow">if</span> (mysched.sched_priority &lt; 1 ) {
00614                 mysched.sched_priority = 1;
00615         }
00616         <span class="keywordflow">if</span> (sched_setscheduler(0, policy, &amp;mysched) &lt; 0) {
00617                 <span class="keywordflow">return</span> 0;
00618         }
00619         rtai_iopl();
00620 
00621         <span class="keywordflow">return</span> (RT_TASK *)rtai_lxrt(BIDX, SIZARG, LXRT_TASK_INIT, &amp;arg).v[LOW];
00622 }
00623 
00624 <span class="preprocessor">#define RT_THREAD_STACK_MIN 64*1024</span>
00625 <span class="preprocessor"></span>
00626 <span class="preprocessor">#if 1</span>
00627 <span class="preprocessor"></span><span class="preprocessor">#include &lt;pthread.h&gt;</span>
00628 
00629 RTAI_PROTO(<span class="keywordtype">int</span>, rt_thread_create,(<span class="keywordtype">void</span> *fun, <span class="keywordtype">void</span> *args, <span class="keywordtype">int</span> stack_size))
00630 {
00631         pthread_t thread;
00632         pthread_attr_t attr;
00633         pthread_attr_init(&amp;attr);
00634         <span class="keywordflow">if</span> (pthread_attr_setstacksize(&amp;attr, stack_size &gt; RT_THREAD_STACK_MIN ? stack_size : RT_THREAD_STACK_MIN)) {
00635                 <span class="keywordflow">return</span> -1;
00636         }
00637         <span class="keywordflow">if</span> (pthread_create(&amp;thread, &amp;attr, (<span class="keywordtype">void</span> *(*)(<span class="keywordtype">void</span> *))fun, args)) {
00638                 <span class="keywordflow">return</span> -1;
00639         }
00640         <span class="keywordflow">return</span> thread;
00641 }
00642 
00643 RTAI_PROTO(<span class="keywordtype">int</span>, rt_thread_join, (<span class="keywordtype">int</span> thread))
00644 {
00645         <span class="keywordflow">return</span> pthread_join((pthread_t)thread, NULL);
00646 }
00647 
00648 <span class="preprocessor">#else</span>
00649 <span class="preprocessor"></span>
00650 <span class="preprocessor">#include &lt;sys/wait.h&gt;</span>
00651 
00652 RTAI_PROTO(<span class="keywordtype">int</span>, rt_thread_create, (<span class="keywordtype">void</span> *fun, <span class="keywordtype">void</span> *args, <span class="keywordtype">int</span> stack_size))
00653 {
00654         <span class="keywordtype">void</span> *sp;
00655         <span class="keywordflow">if</span> (stack_size &lt; RT_THREAD_STACK_MIN) {
00656                 stack_size = RT_THREAD_STACK_MIN;
00657         }
00658         memset(sp = malloc(stack_size), 0, stack_size);
00659         sp = (<span class="keywordtype">void</span> *)(((<span class="keywordtype">unsigned</span> long)sp + stack_size - 16) &amp; ~0xF);
00660         <span class="keywordflow">return</span> clone(fun, sp, CLONE_VM | CLONE_FS | CLONE_FILES, args);
00661 }
00662 
00663 RTAI_PROTO(<span class="keywordtype">int</span>, rt_thread_join, (<span class="keywordtype">int</span> thread))
00664 {
00665         <span class="keywordflow">return</span> waitpid(thread, NULL, 0);
00666 }
00667 
00668 <span class="preprocessor">#endif</span>
00669 <span class="preprocessor"></span>
00670 <span class="preprocessor">#ifndef __SUPPORT_LINUX_SERVER__</span>
00671 <span class="preprocessor"></span><span class="preprocessor">#define __SUPPORT_LINUX_SERVER__</span>
00672 <span class="preprocessor"></span>
00673 <span class="preprocessor">#include &lt;asm/ptrace.h&gt;</span>
00674 <span class="preprocessor">#include &lt;unistd.h&gt;</span>
00675 
00676 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">void</span> rt_receive_linux_syscall(RT_TASK *task, <span class="keyword">struct</span> pt_regs *regs)
00677 {
00678         <span class="keyword">struct </span>{ RT_TASK *task; <span class="keyword">struct </span>pt_regs *regs; } arg = { task, regs };
00679         rtai_lxrt(BIDX, SIZARG, RECEIVE_LINUX_SYSCALL, &amp;arg);
00680 }
00681 
00682 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">void</span> rt_return_linux_syscall(RT_TASK *task, <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> retval)
00683 {
00684         <span class="keyword">struct </span>{ RT_TASK *task; <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> retval; } arg = { task, retval };
00685         rtai_lxrt(BIDX, SIZARG, RETURN_LINUX_SYSCALL, &amp;arg);
00686 }
00687 
00688 <span class="preprocessor">#include &lt;rtai_msg.h&gt;</span>
00689 <span class="keyword">static</span> <span class="keywordtype">void</span> linux_syscall_server_fun(RT_TASK *task)
00690 {
00691         <span class="keyword">struct </span>pt_regs regs;
00692         rtai_lxrt(BIDX, <span class="keyword">sizeof</span>(RT_TASK *), LINUX_SERVER_INIT, &amp;task);
00693         rtai_lxrt(BIDX, <span class="keyword">sizeof</span>(RT_TASK *), RESUME, &amp;task);
00694         <span class="keywordflow">for</span> (;;) {
00695 <span class="preprocessor">#if 1</span>
00696 <span class="preprocessor"></span>                rt_receive_linux_syscall(task, &amp;regs);
00697                 rt_return_linux_syscall(task, syscall(regs.LINUX_SYSCALL_NR, regs.LINUX_SYSCALL_REG1, regs.LINUX_SYSCALL_REG2, regs.LINUX_SYSCALL_REG3, regs.LINUX_SYSCALL_REG4, regs.LINUX_SYSCALL_REG5, regs.LINUX_SYSCALL_REG6));
00698 <span class="preprocessor">#else</span>
00699 <span class="preprocessor"></span>                <span class="keywordtype">int</span> retval;
00700                 <a class="code" href="group__msg.html#ga14">rt_receivex</a>(task, &amp;regs, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> pt_regs), &amp;retval);
00701                 retval = syscall(regs.LINUX_SYSCALL_NR, regs.LINUX_SYSCALL_REG1, regs.LINUX_SYSCALL_REG2, regs.LINUX_SYSCALL_REG3, regs.LINUX_SYSCALL_REG4, regs.LINUX_SYSCALL_REG5, regs.LINUX_SYSCALL_REG6);
00702                 <a class="code" href="group__rpc.html#ga8">rt_returnx</a>(task, &amp;retval, <span class="keyword">sizeof</span>(retval));
00703 <span class="preprocessor">#endif</span>
00704 <span class="preprocessor"></span>        }
00705 }
00706 
00707 <span class="preprocessor">#endif </span><span class="comment">/* __SUPPORT_LINUX_SERVER__ */</span>
00708 
00709 RTAI_PROTO(<span class="keywordtype">int</span>, rt_linux_syscall_server_create, (RT_TASK * task))
00710 {
00711         <span class="keywordflow">if</span> (rt_thread_create((<span class="keywordtype">void</span> *)linux_syscall_server_fun, task, 0) &gt; 0) {
00712                 printf(<span class="stringliteral">" \b"</span>);
00713                 rtai_lxrt(BIDX, <span class="keyword">sizeof</span>(RT_TASK *), SUSPEND, &amp;task);
00714                 <span class="keywordflow">return</span> 0;
00715         }
00716         <span class="keywordflow">return</span> -1;
00717 }
00718 
00719 RTAI_PROTO(RT_TASK *, rt_thread_init, (<span class="keywordtype">int</span> name, <span class="keywordtype">int</span> priority, <span class="keywordtype">int</span> max_msg_size, <span class="keywordtype">int</span> policy, <span class="keywordtype">int</span> cpus_allowed))
00720 {
00721         <span class="keywordflow">return</span> rt_task_init_schmod(name, priority, 0, max_msg_size, policy, cpus_allowed);
00722 }
00723 
<a name="l00777"></a><a class="code" href="group__lxrt.html#ga10">00777</a> RTAI_PROTO(RT_TASK *,<a class="code" href="group__lxrt.html#ga10">rt_task_init</a>,(<span class="keywordtype">int</span> name, <span class="keywordtype">int</span> priority, <span class="keywordtype">int</span> stack_size, <span class="keywordtype">int</span> max_msg_size))
00778 {
00779         <span class="keywordflow">return</span> rt_task_init_schmod(name, priority, 0, max_msg_size, SCHED_FIFO, 0xFF);
00780 }
00781 
00782 RTAI_PROTO(<span class="keywordtype">void</span>,rt_set_sched_policy,(RT_TASK *task, <span class="keywordtype">int</span> policy, <span class="keywordtype">int</span> rr_quantum_ns))
00783 {
00784         <span class="keyword">struct </span>{ RT_TASK *task; <span class="keywordtype">int</span> policy; <span class="keywordtype">int</span> rr_quantum_ns; } arg = { task, policy, rr_quantum_ns };
00785         rtai_lxrt(BIDX, SIZARG, SET_SCHED_POLICY, &amp;arg);
00786 }
00787 
00788 RTAI_PROTO(<span class="keywordtype">int</span>,rt_change_prio,(RT_TASK *task, <span class="keywordtype">int</span> priority))
00789 {
00790         <span class="keyword">struct </span>{ RT_TASK *task; <span class="keywordtype">int</span> priority; } arg = { task, priority };
00791         <span class="keywordflow">return</span> rtai_lxrt(BIDX, SIZARG, CHANGE_TASK_PRIO, &amp;arg).i[LOW];
00792 }
00793 
<a name="l00806"></a><a class="code" href="group__lxrt.html#ga13">00806</a> RTAI_PROTO(<span class="keywordtype">void</span>,<a class="code" href="group__lxrt.html#ga13">rt_make_soft_real_time</a>,(<span class="keywordtype">void</span>))
00807 {
00808         <span class="keyword">struct </span>{ <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> dummy; } arg;
00809         rtai_lxrt(BIDX, SIZARG, MAKE_SOFT_RT, &amp;arg);
00810 }
00811 
00812 RTAI_PROTO(<span class="keywordtype">int</span>,rt_task_delete,(RT_TASK *task))
00813 {
00814         <span class="keyword">struct </span>{ RT_TASK *task; } arg = { task };
00815         <a class="code" href="group__lxrt.html#ga13">rt_make_soft_real_time</a>();
00816         <span class="keywordflow">return</span> rtai_lxrt(BIDX, SIZARG, LXRT_TASK_DELETE, &amp;arg).i[LOW];
00817 }
00818 
00819 RTAI_PROTO(<span class="keywordtype">int</span>,rt_task_yield,(<span class="keywordtype">void</span>))
00820 {
00821         <span class="keyword">struct </span>{ <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> dummy; } arg;
00822         <span class="keywordflow">return</span> rtai_lxrt(BIDX, SIZARG, YIELD, &amp;arg).i[LOW];
00823 }
00824 
00825 RTAI_PROTO(<span class="keywordtype">int</span>,rt_task_suspend,(RT_TASK *task))
00826 {
00827         <span class="keyword">struct </span>{ RT_TASK *task; } arg = { task };
00828         <span class="keywordflow">return</span> rtai_lxrt(BIDX, SIZARG, SUSPEND, &amp;arg).i[LOW];
00829 }
00830 
00831 RTAI_PROTO(<span class="keywordtype">int</span>,rt_task_suspend_if,(RT_TASK *task))
00832 {
00833         <span class="keyword">struct </span>{ RT_TASK *task; } arg = { task };
00834         <span class="keywordflow">return</span> rtai_lxrt(BIDX, SIZARG, SUSPEND_IF, &amp;arg).i[LOW];
00835 }
00836 
00837 RTAI_PROTO(<span class="keywordtype">int</span>,rt_task_suspend_until,(RT_TASK *task, RTIME time))
00838 {
00839         <span class="keyword">struct </span>{ RT_TASK *task; RTIME time; } arg = { task, time };
00840         <span class="keywordflow">return</span> rtai_lxrt(BIDX, SIZARG, SUSPEND_UNTIL, &amp;arg).i[LOW];
00841 }
00842 
00843 RTAI_PROTO(<span class="keywordtype">int</span>,rt_task_suspend_timed,(RT_TASK *task, RTIME delay))
00844 {
00845         <span class="keyword">struct </span>{ RT_TASK *task; RTIME delay; } arg = { task, delay };
00846         <span class="keywordflow">return</span> rtai_lxrt(BIDX, SIZARG, SUSPEND_TIMED, &amp;arg).i[LOW];
00847 }
00848 
00849 RTAI_PROTO(<span class="keywordtype">int</span>,rt_task_resume,(RT_TASK *task))
00850 {
00851         <span class="keyword">struct </span>{ RT_TASK *task; } arg = { task };
00852         <span class="keywordflow">return</span> rtai_lxrt(BIDX, SIZARG, RESUME, &amp;arg).i[LOW];
00853 }
00854 
00855 RTAI_PROTO(<span class="keywordtype">void</span>, rt_sched_lock, (<span class="keywordtype">void</span>))
00856 {
00857         <span class="keyword">struct </span>{ <span class="keywordtype">int</span> dummy; } arg;
00858         rtai_lxrt(BIDX, SIZARG, SCHED_LOCK, &amp;arg);
00859 }
00860 
00861 RTAI_PROTO(<span class="keywordtype">void</span>, rt_sched_unlock, (<span class="keywordtype">void</span>))
00862 {
00863         <span class="keyword">struct </span>{ <span class="keywordtype">int</span> dummy; } arg;
00864         rtai_lxrt(BIDX, SIZARG, SCHED_UNLOCK, &amp;arg);
00865 }
00866 
00867 RTAI_PROTO(<span class="keywordtype">void</span>, <a class="code" href="group__hal.html#ga95">rt_pend_linux_irq</a>, (<span class="keywordtype">unsigned</span> irq))
00868 {
00869         <span class="keyword">struct </span>{ <span class="keywordtype">unsigned</span> irq; } arg = { irq };
00870         rtai_lxrt(BIDX, SIZARG, PEND_LINUX_IRQ, &amp;arg);
00871 }
00872 
00873 RTAI_PROTO(<span class="keywordtype">int</span>, rt_irq_wait, (<span class="keywordtype">unsigned</span> irq))
00874 {
00875         <span class="keyword">struct </span>{ <span class="keywordtype">unsigned</span> irq; } arg = { irq };
00876         <span class="keywordflow">return</span> rtai_lxrt(BIDX, SIZARG, IRQ_WAIT, &amp;arg).i[LOW];
00877 }
00878 
00879 RTAI_PROTO(<span class="keywordtype">int</span>, rt_irq_wait_if, (<span class="keywordtype">unsigned</span> irq))
00880 {
00881         <span class="keyword">struct </span>{ <span class="keywordtype">unsigned</span> irq; } arg = { irq };
00882         <span class="keywordflow">return</span> rtai_lxrt(BIDX, SIZARG, IRQ_WAIT_IF, &amp;arg).i[LOW];
00883 }
00884 
00885 RTAI_PROTO(<span class="keywordtype">int</span>, rt_irq_wait_until, (<span class="keywordtype">unsigned</span> irq, RTIME time))
00886 {
00887         <span class="keyword">struct </span>{ <span class="keywordtype">unsigned</span> irq; RTIME time; } arg = { irq, time };
00888         <span class="keywordflow">return</span> rtai_lxrt(BIDX, SIZARG, IRQ_WAIT_UNTIL, &amp;arg).i[LOW];
00889 }
00890 
00891 RTAI_PROTO(<span class="keywordtype">int</span>, rt_irq_wait_timed, (<span class="keywordtype">unsigned</span> irq, RTIME delay))
00892 {
00893         <span class="keyword">struct </span>{ <span class="keywordtype">unsigned</span> irq; RTIME delay; } arg = { irq, delay };
00894         <span class="keywordflow">return</span> rtai_lxrt(BIDX, SIZARG, IRQ_WAIT_TIMED, &amp;arg).i[LOW];
00895 }
00896 
00897 RTAI_PROTO(<span class="keywordtype">int</span>, rt_irq_signal, (<span class="keywordtype">unsigned</span> irq))
00898 {
00899         <span class="keyword">struct </span>{ <span class="keywordtype">unsigned</span> irq; } arg = { irq };
00900         <span class="keywordflow">return</span> rtai_lxrt(BIDX, SIZARG, IRQ_SIGNAL, &amp;arg).i[LOW];
00901 }
00902 
00903 RTAI_PROTO(<span class="keywordtype">int</span>, rt_request_irq_task, (<span class="keywordtype">unsigned</span> irq, <span class="keywordtype">void</span> *handler, <span class="keywordtype">int</span> type, <span class="keywordtype">int</span> affine2task))
00904 {
00905         <span class="keyword">struct </span>{ <span class="keywordtype">unsigned</span> irq; <span class="keywordtype">void</span> *handler; <span class="keywordtype">int</span> type, affine2task; } arg = { irq, handler, type, affine2task };
00906         <span class="keywordflow">return</span> rtai_lxrt(BIDX, SIZARG, REQUEST_IRQ_TASK, &amp;arg).i[LOW];
00907 }
00908 
00909 
00910 RTAI_PROTO(<span class="keywordtype">int</span>, rt_release_irq_task, (<span class="keywordtype">unsigned</span> irq))
00911 {
00912         <span class="keyword">struct </span>{ <span class="keywordtype">unsigned</span> irq; } arg = { irq };
00913         <span class="keywordflow">return</span> rtai_lxrt(BIDX, SIZARG, RELEASE_IRQ_TASK, &amp;arg).i[LOW];
00914 }
00915 
00916 RTAI_PROTO(<span class="keywordtype">int</span>, rt_task_make_periodic,(RT_TASK *task, RTIME start_time, RTIME period))
00917 {
00918         <span class="keyword">struct </span>{ RT_TASK *task; RTIME start_time, period; } arg = { task, start_time, period };
00919         <span class="keywordflow">return</span> rtai_lxrt(BIDX, SIZARG, MAKE_PERIODIC, &amp;arg).i[LOW];
00920 }
00921 
00922 RTAI_PROTO(<span class="keywordtype">int</span>,rt_task_make_periodic_relative_ns,(RT_TASK *task, RTIME start_delay, RTIME period))
00923 {
00924         <span class="keyword">struct </span>{ RT_TASK *task; RTIME start_time, period; } arg = { task, start_delay, period };
00925         <span class="keywordflow">return</span> rtai_lxrt(BIDX, SIZARG, MAKE_PERIODIC_NS, &amp;arg).i[LOW];
00926 }
00927 
00928 RTAI_PROTO(<span class="keywordtype">int</span>, rt_task_wait_period,(<span class="keywordtype">void</span>))
00929 {
00930         <span class="keyword">struct </span>{ <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> dummy; } arg;
00931         <span class="keywordflow">return</span> rtai_lxrt(BIDX, SIZARG, WAIT_PERIOD, &amp;arg).i[LOW];
00932 }
00933 
00934 RTAI_PROTO(<span class="keywordtype">int</span>, rt_sleep,(RTIME delay))
00935 {
00936         <span class="keyword">struct </span>{ RTIME delay; } arg = { delay };
00937         <span class="keywordflow">return</span> rtai_lxrt(BIDX, SIZARG, SLEEP, &amp;arg).i[LOW];
00938 }
00939 
00940 RTAI_PROTO(<span class="keywordtype">int</span>, rt_sleep_until,(RTIME time))
00941 {
00942         <span class="keyword">struct </span>{ RTIME time; } arg = { time };
00943         <span class="keywordflow">return</span> rtai_lxrt(BIDX, SIZARG, SLEEP_UNTIL, &amp;arg).i[LOW];
00944 }
00945 
00946 RTAI_PROTO(<span class="keywordtype">int</span>,rt_is_hard_timer_running,(<span class="keywordtype">void</span>))
00947 {
00948         <span class="keyword">struct </span>{ <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> dummy; } arg;
00949         <span class="keywordflow">return</span> rtai_lxrt(BIDX, SIZARG, HARD_TIMER_RUNNING, &amp;arg).i[LOW];
00950 }
00951 
00952 RTAI_PROTO(RTIME, start_rt_timer,(<span class="keywordtype">int</span> period))
00953 {
00954         <span class="keyword">struct </span>{ <span class="keywordtype">int</span> period; } arg = { period };
00955         <span class="keywordflow">return</span> rtai_lxrt(BIDX, SIZARG, START_TIMER, &amp;arg).rt;
00956 }
00957 
00958 RTAI_PROTO(<span class="keywordtype">void</span>, stop_rt_timer,(<span class="keywordtype">void</span>))
00959 {
00960         <span class="keyword">struct </span>{ <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> dummy; } arg;
00961         rtai_lxrt(BIDX, SIZARG, STOP_TIMER, &amp;arg);
00962 }
00963 
00964 RTAI_PROTO(RTIME,rt_get_time,(<span class="keywordtype">void</span>))
00965 {
00966         <span class="keyword">struct </span>{ <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> dummy; } arg;
00967         <span class="keywordflow">return</span> rtai_lxrt(BIDX, SIZARG, GET_TIME, &amp;arg).rt;
00968 }
00969 
00970 RTAI_PROTO(RTIME,count2nano,(RTIME count))
00971 {
00972         <span class="keyword">struct </span>{ RTIME count; } arg = { count };
00973         <span class="keywordflow">return</span> rtai_lxrt(BIDX, SIZARG, COUNT2NANO, &amp;arg).rt;
00974 }
00975 
00976 RTAI_PROTO(RTIME,nano2count,(RTIME nanos))
00977 {
00978         <span class="keyword">struct </span>{ RTIME nanos; } arg = { nanos };
00979         <span class="keywordflow">return</span> rtai_lxrt(BIDX, SIZARG, NANO2COUNT, &amp;arg).rt;
00980 }
00981 
00982 RTAI_PROTO(<span class="keywordtype">void</span>,rt_busy_sleep,(<span class="keywordtype">int</span> ns))
00983 {
00984         <span class="keyword">struct </span>{ <span class="keywordtype">int</span> ns; } arg = { ns };
00985         rtai_lxrt(BIDX, SIZARG, BUSY_SLEEP, &amp;arg);
00986 }
00987 
00988 RTAI_PROTO(<span class="keywordtype">void</span>,rt_set_periodic_mode,(<span class="keywordtype">void</span>))
00989 {
00990         <span class="keyword">struct </span>{ <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> dummy; } arg;
00991         rtai_lxrt(BIDX, SIZARG, SET_PERIODIC_MODE, &amp;arg);
00992 }
00993 
00994 RTAI_PROTO(<span class="keywordtype">void</span>,rt_set_oneshot_mode,(<span class="keywordtype">void</span>))
00995 {
00996         <span class="keyword">struct </span>{ <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> dummy; } arg;
00997         rtai_lxrt(BIDX, SIZARG, SET_ONESHOT_MODE, &amp;arg);
00998 }
00999 
01000 RTAI_PROTO(<span class="keywordtype">int</span>,rt_task_signal_handler,(RT_TASK *task, <span class="keywordtype">void</span> (*handler)(<span class="keywordtype">void</span>)))
01001 {
01002         <span class="keyword">struct </span>{ RT_TASK *task; void (*handler)(void); } arg = { task, handler };
01003         <span class="keywordflow">return</span> rtai_lxrt(BIDX, SIZARG, SIGNAL_HANDLER, &amp;arg).i[LOW];
01004 }
01005 
01006 RTAI_PROTO(<span class="keywordtype">int</span>,rt_task_use_fpu,(RT_TASK *task, <span class="keywordtype">int</span> use_fpu_flag))
01007 {
01008         <span class="keyword">struct </span>{ RT_TASK *task; <span class="keywordtype">int</span> use_fpu_flag; } arg = { task, use_fpu_flag };
01009         <span class="keywordflow">if</span> (rtai_lxrt(BIDX, SIZARG, RT_BUDDY, &amp;arg).v[LOW] != task) {
01010                 <span class="keywordflow">return</span> rtai_lxrt(BIDX, SIZARG, TASK_USE_FPU, &amp;arg).i[LOW];
01011         } <span class="keywordflow">else</span> {
01012 <span class="comment">// note that it would be enough to do whatever FP op here to have it OK. But</span>
01013 <span class="comment">// that is scary if it is done when already in hard real time, and we do not</span>
01014 <span class="comment">// want to force users to call this before making it hard.</span>
01015                 rtai_lxrt(BIDX, SIZARG, HRT_USE_FPU, &amp;arg);
01016                 <span class="keywordflow">return</span> 0;
01017         }
01018 }
01019 
01020 RTAI_PROTO(<span class="keywordtype">int</span>,rt_buddy_task_use_fpu,(RT_TASK *task, <span class="keywordtype">int</span> use_fpu_flag))
01021 {
01022         <span class="keyword">struct </span>{ RT_TASK *task; <span class="keywordtype">int</span> use_fpu_flag; } arg = { task, use_fpu_flag };
01023         <span class="keywordflow">return</span> rtai_lxrt(BIDX, SIZARG, TASK_USE_FPU, &amp;arg).i[LOW];
01024 }
01025 
01026 RTAI_PROTO(<span class="keywordtype">int</span>,rt_linux_use_fpu,(<span class="keywordtype">int</span> use_fpu_flag))
01027 {
01028         <span class="keyword">struct </span>{ <span class="keywordtype">int</span> use_fpu_flag; } arg = { use_fpu_flag };
01029         <span class="keywordflow">return</span> rtai_lxrt(BIDX, SIZARG, LINUX_USE_FPU, &amp;arg).i[LOW];
01030 }
01031 
01032 RTAI_PROTO(<span class="keywordtype">void</span>,rt_preempt_always,(<span class="keywordtype">int</span> yes_no))
01033 {
01034         <span class="keyword">struct </span>{ <span class="keywordtype">int</span> yes_no; } arg = { yes_no };
01035         rtai_lxrt(BIDX, SIZARG, PREEMPT_ALWAYS_GEN, &amp;arg);
01036 }
01037 
01038 RTAI_PROTO(RTIME,rt_get_time_ns,(<span class="keywordtype">void</span>))
01039 {
01040         <span class="keyword">struct </span>{ <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> dummy; } arg;
01041         <span class="keywordflow">return</span> rtai_lxrt(BIDX, SIZARG, GET_TIME_NS, &amp;arg).rt;
01042 }
01043 
01044 RTAI_PROTO(RTIME,rt_get_cpu_time_ns,(<span class="keywordtype">void</span>))
01045 {
01046         <span class="keyword">struct </span>{ <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> dummy; } arg;
01047         <span class="keywordflow">return</span> rtai_lxrt(BIDX, SIZARG, GET_CPU_TIME_NS, &amp;arg).rt;
01048 }
01049 
01050 <span class="preprocessor">#define rt_named_task_init(task_name, thread, data, stack_size, prio, uses_fpu, signal) \</span>
01051 <span class="preprocessor">        rt_task_init(nam2num(task_name), thread, data, stack_size, prio, uses_fpu, signal)</span>
01052 <span class="preprocessor"></span>
01053 <span class="preprocessor">#define rt_named_task_init_cpuid(task_name, thread, data, stack_size, prio, uses_fpu, signal, run_on_cpu) \</span>
01054 <span class="preprocessor">        rt_task_init_cpuid(nam2num(task_name), thread, data, stack_size, prio, uses_fpu, signal, run_on_cpu)</span>
01055 <span class="preprocessor"></span>
01056 RTAI_PROTO(<span class="keywordtype">void</span>,rt_set_runnable_on_cpus,(RT_TASK *task, <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> cpu_mask))
01057 {
01058         <span class="keyword">struct </span>{ RT_TASK *task; <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> cpu_mask; } arg = { task, cpu_mask };
01059         rtai_lxrt(BIDX, SIZARG, SET_RUNNABLE_ON_CPUS, &amp;arg);
01060 }
01061 
01062 RTAI_PROTO(<span class="keywordtype">void</span>,rt_set_runnable_on_cpuid,(RT_TASK *task, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cpuid))
01063 {
01064         <span class="keyword">struct </span>{ RT_TASK *task; <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cpuid; } arg = { task, cpuid };
01065         rtai_lxrt(BIDX, SIZARG, SET_RUNNABLE_ON_CPUID, &amp;arg);
01066 }
01067 
01068 RTAI_PROTO(<span class="keywordtype">int</span>,rt_get_timer_cpu,(<span class="keywordtype">void</span>))
01069 {
01070         <span class="keyword">struct </span>{ <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> dummy; } arg;
01071         <span class="keywordflow">return</span> rtai_lxrt(BIDX, SIZARG, GET_TIMER_CPU, &amp;arg).i[LOW];
01072 }
01073 
01074 RTAI_PROTO(<span class="keywordtype">void</span>,start_rt_apic_timers,(<span class="keyword">struct</span> apic_timer_setup_data *setup_mode, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> rcvr_jiffies_cpuid))
01075 {
01076         <span class="keyword">struct </span>{ <span class="keyword">struct </span>apic_timer_setup_data *setup_mode; <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> rcvr_jiffies_cpuid; } arg = { setup_mode, rcvr_jiffies_cpuid };
01077         rtai_lxrt(BIDX, SIZARG, START_RT_APIC_TIMERS, &amp;arg);
01078 }
01079 
01080 RTAI_PROTO(<span class="keywordtype">void</span>,rt_preempt_always_cpuid,(<span class="keywordtype">int</span> yes_no, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cpuid))
01081 {
01082         <span class="keyword">struct </span>{ <span class="keywordtype">int</span> yes_no; <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cpuid; } arg = { yes_no, cpuid };
01083         rtai_lxrt(BIDX, SIZARG, PREEMPT_ALWAYS_CPUID, &amp;arg);
01084 }
01085 
01086 RTAI_PROTO(RTIME,count2nano_cpuid,(RTIME count, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cpuid))
01087 {
01088         <span class="keyword">struct </span>{ RTIME count; <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cpuid; } arg = { count, cpuid };
01089         <span class="keywordflow">return</span> rtai_lxrt(BIDX, SIZARG, COUNT2NANO_CPUID, &amp;arg).rt;
01090 }
01091 
01092 RTAI_PROTO(RTIME,nano2count_cpuid,(RTIME nanos, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cpuid))
01093 {
01094         <span class="keyword">struct </span>{ RTIME nanos; <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cpuid; } arg = { nanos, cpuid };
01095         <span class="keywordflow">return</span> rtai_lxrt(BIDX, SIZARG, NANO2COUNT_CPUID, &amp;arg).rt;
01096 }
01097 
01098 RTAI_PROTO(RTIME,rt_get_time_cpuid,(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cpuid))
01099 {
01100         <span class="keyword">struct </span>{ <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cpuid; } arg = { cpuid };
01101         <span class="keywordflow">return</span> rtai_lxrt(BIDX, SIZARG, GET_TIME_CPUID, &amp;arg).rt;
01102 }
01103 
01104 RTAI_PROTO(RTIME,rt_get_time_ns_cpuid,(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cpuid))
01105 {
01106         <span class="keyword">struct </span>{ <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cpuid; } arg = { cpuid };
01107         <span class="keywordflow">return</span> rtai_lxrt(BIDX, SIZARG, GET_TIME_NS_CPUID, &amp;arg).rt;
01108 }
01109 
01110 RTAI_PROTO(<span class="keywordtype">void</span>,rt_boom,(<span class="keywordtype">void</span>))
01111 {
01112         <span class="keyword">struct </span>{ <span class="keywordtype">int</span> dummy; } arg = { 0 };
01113         rtai_lxrt(BIDX, SIZARG, RT_BOOM, &amp;arg);
01114 }
01115 
01116 RTAI_PROTO(<span class="keywordtype">void</span>,rt_mmgr_stats,(<span class="keywordtype">void</span>))
01117 {
01118         <span class="keyword">struct </span>{ <span class="keywordtype">int</span> dummy; } arg = { 0 };
01119         rtai_lxrt(BIDX, SIZARG, RT_MMGR_STATS, &amp;arg);
01120 }
01121 
01122 RTAI_PROTO(<span class="keywordtype">void</span>,rt_stomp,(<span class="keywordtype">void</span>) )
01123 {
01124         <span class="keyword">struct </span>{ <span class="keywordtype">int</span> dummy; } arg = { 0 };
01125         rtai_lxrt(BIDX, SIZARG, RT_STOMP, &amp;arg);
01126 }
01127 
01128 RTAI_PROTO(<span class="keywordtype">int</span>,rt_get_linux_signal,(RT_TASK *task))
01129 {
01130     <span class="keyword">struct </span>{ RT_TASK *task; } arg = { task };
01131     <span class="keywordflow">return</span> rtai_lxrt(BIDX, SIZARG, RT_GET_LINUX_SIGNAL, &amp;arg).i[LOW];
01132 }
01133 
01134 RTAI_PROTO(<span class="keywordtype">int</span>,rt_get_errno,(RT_TASK *task))
01135 {
01136     <span class="keyword">struct </span>{ RT_TASK *task; } arg = { task };
01137     <span class="keywordflow">return</span> rtai_lxrt(BIDX, SIZARG, RT_GET_ERRNO, &amp;arg).i[LOW];
01138 }
01139 
01140 RTAI_PROTO(<span class="keywordtype">int</span>,rt_set_linux_signal_handler,(RT_TASK *task, <span class="keywordtype">void</span> (*handler)(<span class="keywordtype">int</span> sig)))
01141 {
01142     <span class="keyword">struct </span>{ RT_TASK *task; void (*handler)(<span class="keywordtype">int</span> sig); } arg = { task, handler };
01143     <span class="keywordflow">return</span> rtai_lxrt(BIDX, SIZARG, RT_SET_LINUX_SIGNAL_HANDLER, &amp;arg).i[LOW];
01144 }
01145 
01146 RTAI_PROTO(<span class="keywordtype">int</span>,rtai_print_to_screen,(<span class="keyword">const</span> <span class="keywordtype">char</span> *format, ...))
01147 {
01148         <span class="keywordtype">char</span> display[256];
01149         <span class="keyword">struct </span>{ <span class="keyword">const</span> <span class="keywordtype">char</span> *display; <span class="keywordtype">int</span> nch; } arg = { display, 0 };
01150         va_list args;
01151 
01152         va_start(args, format);
01153         arg.nch = vsprintf(display, format, args);
01154         va_end(args);
01155         rtai_lxrt(BIDX, SIZARG, PRINT_TO_SCREEN, &amp;arg);
01156         <span class="keywordflow">return</span> arg.nch;
01157 }
01158 
01159 RTAI_PROTO(<span class="keywordtype">int</span>,rt_printk,(<span class="keyword">const</span> <span class="keywordtype">char</span> *format, ...))
01160 {
01161         <span class="keywordtype">char</span> display[256];
01162         <span class="keyword">struct </span>{ <span class="keyword">const</span> <span class="keywordtype">char</span> *display; <span class="keywordtype">int</span> nch; } arg = { display, 0 };
01163         va_list args;
01164 
01165         va_start(args, format);
01166         arg.nch = vsprintf(display, format, args);
01167         va_end(args);
01168         rtai_lxrt(BIDX, SIZARG, PRINTK, &amp;arg);
01169         <span class="keywordflow">return</span> arg.nch;
01170 }
01171 
01172 RTAI_PROTO(<span class="keywordtype">int</span>,rt_usp_signal_handler,(<span class="keywordtype">void</span> (*handler)(<span class="keywordtype">void</span>)))
01173 {
01174         <span class="keyword">struct </span>{ void (*handler)(void); } arg = { handler };
01175         <span class="keywordflow">return</span> rtai_lxrt(BIDX, SIZARG, USP_SIGHDL, &amp;arg).i[0];
01176 }
01177 
01178 RTAI_PROTO(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span>,rt_get_usp_flags,(RT_TASK *rt_task))
01179 {
01180         <span class="keyword">struct </span>{ RT_TASK *task; } arg = { rt_task };
01181         <span class="keywordflow">return</span> rtai_lxrt(BIDX, SIZARG, GET_USP_FLAGS, &amp;arg).i[LOW];
01182 }
01183 
01184 RTAI_PROTO(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span>,rt_get_usp_flags_mask,(RT_TASK *rt_task))
01185 {
01186         <span class="keyword">struct </span>{ RT_TASK *task; } arg = { rt_task };
01187         <span class="keywordflow">return</span> rtai_lxrt(BIDX, SIZARG, GET_USP_FLG_MSK, &amp;arg).i[LOW];
01188 }
01189 
01190 RTAI_PROTO(<span class="keywordtype">void</span>,rt_set_usp_flags,(RT_TASK *rt_task, <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> flags))
01191 {
01192         <span class="keyword">struct </span>{ RT_TASK *task; <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> flags; } arg = { rt_task, flags };
01193         rtai_lxrt(BIDX, SIZARG, SET_USP_FLAGS, &amp;arg);
01194 }
01195 
01196 RTAI_PROTO(<span class="keywordtype">void</span>,rt_set_usp_flags_mask,(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> flags_mask))
01197 {
01198         <span class="keyword">struct </span>{ <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> flags_mask; } arg = { flags_mask };
01199         rtai_lxrt(BIDX, SIZARG, SET_USP_FLG_MSK, &amp;arg);
01200 }
01201 
01202 RTAI_PROTO(RT_TASK *,rt_force_task_soft,(<span class="keywordtype">int</span> pid))
01203 {
01204         <span class="keyword">struct </span>{ <span class="keywordtype">int</span> pid; } arg = { pid };
01205         <span class="keywordflow">return</span> (RT_TASK *)rtai_lxrt(BIDX, SIZARG, FORCE_TASK_SOFT, &amp;arg).v[LOW];
01206 }
01207 
01208 RTAI_PROTO(RT_TASK *,rt_agent,(<span class="keywordtype">void</span>))
01209 {
01210         <span class="keyword">struct </span>{ <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> dummy; } arg;
01211         <span class="keywordflow">return</span> (RT_TASK *)rtai_lxrt(BIDX, SIZARG, RT_BUDDY, &amp;arg).v[LOW];
01212 }
01213 
01214 <span class="preprocessor">#define rt_buddy() rt_agent()</span>
01215 <span class="preprocessor"></span>
<a name="l01238"></a><a class="code" href="group__lxrt.html#ga76">01238</a> RTAI_PROTO(<span class="keywordtype">void</span>,<a class="code" href="group__lxrt.html#ga76">rt_make_hard_real_time</a>,(<span class="keywordtype">void</span>))
01239 {
01240         <span class="keyword">struct </span>{ <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> dummy; } arg;
01241         rtai_lxrt(BIDX, SIZARG, MAKE_HARD_RT, &amp;arg);
01242 }
01243 
<a name="l01252"></a><a class="code" href="group__lxrt.html#ga77">01252</a> RTAI_PROTO(<span class="keywordtype">void</span>,<a class="code" href="group__lxrt.html#ga77">rt_allow_nonroot_hrt</a>,(<span class="keywordtype">void</span>))
01253 {
01254         <span class="keyword">struct </span>{ <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> dummy; } arg;
01255         rtai_lxrt(BIDX, SIZARG, NONROOT_HRT, &amp;arg);
01256 }
01257 
01258 RTAI_PROTO(<span class="keywordtype">int</span>,rt_is_hard_real_time,(RT_TASK *rt_task))
01259 {
01260         <span class="keyword">struct </span>{ RT_TASK *task; } arg = { rt_task };
01261         <span class="keywordflow">return</span> rtai_lxrt(BIDX, SIZARG, IS_HARD, &amp;arg).i[LOW];
01262 }
01263 
01264 <span class="preprocessor">#define rt_is_soft_real_time(rt_task) (!rt_is_hard_real_time((rt_task)))</span>
01265 <span class="preprocessor"></span>
01266 RTAI_PROTO(<span class="keywordtype">void</span>,rt_task_set_resume_end_times,(RTIME resume, RTIME end))
01267 {
01268         <span class="keyword">struct </span>{ RTIME resume, end; } arg = { resume, end };
01269         rtai_lxrt(BIDX, SIZARG, SET_RESUME_END, &amp;arg);
01270 }
01271 
01272 RTAI_PROTO(<span class="keywordtype">int</span>,rt_set_resume_time,(RT_TASK *rt_task, RTIME new_resume_time))
01273 {
01274         <span class="keyword">struct </span>{ RT_TASK *rt_task; RTIME new_resume_time; } arg = { rt_task, new_resume_time };
01275         <span class="keywordflow">return</span> rtai_lxrt(BIDX, SIZARG, SET_RESUME_TIME, &amp;arg).i[LOW];
01276 }
01277 
01278 RTAI_PROTO(<span class="keywordtype">int</span>,rt_set_period,(RT_TASK *rt_task, RTIME new_period))
01279 {
01280         <span class="keyword">struct </span>{ RT_TASK *rt_task; RTIME new_period; } arg = { rt_task, new_period };
01281         <span class="keywordflow">return</span> rtai_lxrt(BIDX, SIZARG, SET_PERIOD, &amp;arg).i[LOW];
01282 }
01283 
01284 RTAI_PROTO(<span class="keywordtype">void</span>,rt_spv_RMS,(<span class="keywordtype">int</span> cpuid))
01285 {
01286         <span class="keyword">struct </span>{ <span class="keywordtype">int</span> cpuid; } arg = { cpuid };
01287         rtai_lxrt(BIDX, SIZARG, SPV_RMS, &amp;arg);
01288 }
01289 
01290 RTAI_PROTO(<span class="keywordtype">int</span>,rt_task_wakeup_sleeping,(RT_TASK *task))
01291 {
01292         <span class="keyword">struct </span>{ RT_TASK *task; } arg = { task };
01293         <span class="keywordflow">return</span> rtai_lxrt(BIDX, SIZARG, WAKEUP_SLEEPING, &amp;arg).i[LOW];
01294 }
01295 
01296 RTAI_PROTO(<span class="keywordtype">void</span>,rt_get_exectime,(RT_TASK *task, RTIME *exectime))
01297 {
01298         RTIME lexectime[] = { 0LL, 0LL, 0LL };
01299         <span class="keyword">struct </span>{ RT_TASK *task; RTIME *lexectime; } arg = { task, lexectime };
01300         rtai_lxrt(BIDX, SIZARG, GET_EXECTIME, &amp;arg);
01301         memcpy(exectime, lexectime, <span class="keyword">sizeof</span>(lexectime));
01302 }
01303 
01304 RTAI_PROTO(<span class="keywordtype">void</span>,rt_gettimeorig,(RTIME time_orig[]))
01305 {
01306         <span class="keyword">struct </span>{ RTIME *time_orig; } arg = { time_orig };
01307         rtai_lxrt(BIDX, SIZARG, GET_TIMEORIG, &amp;arg);
01308 }
01309 
01310 <span class="preprocessor">#ifdef __cplusplus</span>
01311 <span class="preprocessor"></span>}
01312 <span class="preprocessor">#endif </span><span class="comment">/* __cplusplus */</span>
01313 
01314 <span class="preprocessor">#endif </span><span class="comment">/* __KERNEL__ */</span>
01315 
01318 <span class="preprocessor">#endif </span><span class="comment">/* !_RTAI_LXRT_H */</span>
</pre></div><hr size="1"><address style="align: right;"><small>Generated on Thu Nov 17 12:29:17 2005 for RTAI API by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.4.2 </small></address>
</body>
</html>
