<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>RTAI API: base/include/rtai_tbx.h Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.4.2 -->
<div class="qindex">  <form class="search" action="search.php" method="get">
<a class="qindex" href="main.html">Main&nbsp;Page</a> | <a class="qindex" href="modules.html">Modules</a> | <a class="qindex" href="dirs.html">Directories</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="globals.html">Globals</a> | <a class="qindex" href="pages.html">Related&nbsp;Pages</a>  | <span class="search"><u>S</u>earch&nbsp;for&nbsp;<input class="search" type="text" name="query" value="" size="20" accesskey="s"/></span></form></div>
<div class="nav">
<a class="el" href="dir_000000.html">base</a>&nbsp;/&nbsp;<a class="el" href="dir_000014.html">include</a></div>
<h1>rtai_tbx.h</h1><div class="fragment"><pre class="fragment">00001 <span class="comment">/*</span>
00002 <span class="comment"> * Copyright (C) 2005 Paolo Mantegazza &lt;mantegazza@aero.polimi.it&gt;</span>
00003 <span class="comment"> *</span>
00004 <span class="comment"> * This program is free software; you can redistribute it and/or</span>
00005 <span class="comment"> * modify it under the terms of the GNU General Public License as</span>
00006 <span class="comment"> * published by the Free Software Foundation; either version 2 of the</span>
00007 <span class="comment"> * License, or (at your option) any later version.</span>
00008 <span class="comment"> *</span>
00009 <span class="comment"> * This program is distributed in the hope that it will be useful,</span>
00010 <span class="comment"> * but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
00011 <span class="comment"> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
00012 <span class="comment"> * GNU General Public License for more details.</span>
00013 <span class="comment"> *</span>
00014 <span class="comment"> * You should have received a copy of the GNU General Public License</span>
00015 <span class="comment"> * along with this program; if not, write to the Free Software</span>
00016 <span class="comment"> * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.</span>
00017 <span class="comment"> *</span>
00018 <span class="comment"> */</span>
00019 
00020 
00021 <span class="preprocessor">#ifndef _RTAI_RT_MSGQ_H</span>
00022 <span class="preprocessor"></span><span class="preprocessor">#define _RTAI_RT_MSGQ_H</span>
00023 <span class="preprocessor"></span>
00024 <span class="preprocessor">#include &lt;linux/version.h&gt;</span>
00025 <span class="preprocessor">#include &lt;<a class="code" href="rtai__sem_8h.html">rtai_sem.h</a>&gt;</span>
00026 
00027 <span class="preprocessor">#define MSGQ_INIT            TBX_INIT</span>
00028 <span class="preprocessor"></span><span class="preprocessor">#define MSGQ_DELETE          TBX_DELETE</span>
00029 <span class="preprocessor"></span><span class="preprocessor">#define NAMED_MSGQ_INIT      NAMED_TBX_INIT</span>
00030 <span class="preprocessor"></span><span class="preprocessor">#define NAMED_MSGQ_DELETE    NAMED_TBX_DELETE</span>
00031 <span class="preprocessor"></span><span class="preprocessor">#define MSG_SEND             TBX_SEND</span>
00032 <span class="preprocessor"></span><span class="preprocessor">#define MSG_SEND_IF          TBX_SEND_IF</span>
00033 <span class="preprocessor"></span><span class="preprocessor">#define MSG_SEND_UNTIL       TBX_SEND_UNTIL</span>
00034 <span class="preprocessor"></span><span class="preprocessor">#define MSG_SEND_TIMED       TBX_SEND_TIMED</span>
00035 <span class="preprocessor"></span><span class="preprocessor">#define MSG_RECEIVE          TBX_RECEIVE</span>
00036 <span class="preprocessor"></span><span class="preprocessor">#define MSG_RECEIVE_IF       TBX_RECEIVE_IF</span>
00037 <span class="preprocessor"></span><span class="preprocessor">#define MSG_RECEIVE_UNTIL    TBX_RECEIVE_UNTIL</span>
00038 <span class="preprocessor"></span><span class="preprocessor">#define MSG_RECEIVE_TIMED    TBX_RECEIVE_TIMED</span>
00039 <span class="preprocessor"></span><span class="preprocessor">#define MSG_BROADCAST        TBX_BROADCAST</span>
00040 <span class="preprocessor"></span><span class="preprocessor">#define MSG_BROADCAST_IF     TBX_BROADCAST_IF</span>
00041 <span class="preprocessor"></span><span class="preprocessor">#define MSG_BROADCAST_UNTIL  TBX_BROADCAST_UNTIL</span>
00042 <span class="preprocessor"></span><span class="preprocessor">#define MSG_BROADCAST_TIMED  TBX_BROADCAST_TIMED</span>
00043 <span class="preprocessor"></span><span class="preprocessor">#define MSG_EVDRP            TBX_URGENT</span>
00044 <span class="preprocessor"></span>
00045 <span class="preprocessor">#define TBX  RT_MSGQ</span>
00046 <span class="preprocessor"></span>
00047 <span class="preprocessor">#ifdef __KERNEL__</span>
00048 <span class="preprocessor"></span>
00049 <span class="keyword">typedef</span> <span class="keyword">struct </span>rt_msgh {
00050         <span class="keywordtype">void</span> *malloc;
00051         <span class="keywordtype">int</span> broadcast;
00052         <span class="keywordtype">int</span> size;
00053         <span class="keywordtype">int</span> priority;
00054         <span class="keywordtype">void</span> *next;     
00055 } RT_MSGH;
00056 
00057 <span class="preprocessor">#define RT_MSGH_SIZE  (sizeof(RT_MSGH))</span>
00058 <span class="preprocessor"></span>
00059 <span class="keyword">typedef</span> <span class="keyword">struct </span>rt_msg {
00060         RT_MSGH hdr;
00061         <span class="keywordtype">char</span> msg[1];
00062 } RT_MSG;
00063 
00064 <span class="keyword">typedef</span> <span class="keyword">struct </span>rt_msgq {
00065         <span class="keywordtype">int</span> nmsg;
00066         <span class="keywordtype">int</span> fastsize;
00067         <span class="keywordtype">int</span> slot;
00068         <span class="keywordtype">void</span> **slots;
00069         <span class="keywordtype">void</span> *firstmsg;
00070         SEM receivers, senders;
00071         SEM received, freslots;
00072         SEM broadcast;
00073         spinlock_t lock;
00074 } RT_MSGQ;
00075 
00076 <span class="preprocessor">#include &lt;linux/types.h&gt;</span>
00077 
00078 <span class="preprocessor">#ifdef __cplusplus</span>
00079 <span class="preprocessor"></span><span class="keyword">extern</span> <span class="stringliteral">"C"</span> {
00080 <span class="preprocessor">#endif </span><span class="comment">/* !__cplusplus */</span>
00081 
00082 <span class="keywordtype">int</span> __rtai_msg_queue_init(<span class="keywordtype">void</span>);
00083 
00084 <span class="keywordtype">void</span> __rtai_msg_queue_exit(<span class="keywordtype">void</span>);
00085 
00086 <span class="keywordtype">int</span> rt_msgq_init(RT_MSGQ *msgq, <span class="keywordtype">int</span> nmsg, <span class="keywordtype">int</span> msg_size);
00087 
00088 <span class="keywordtype">int</span> rt_msgq_delete(RT_MSGQ *msgq);
00089 
00090 RT_MSGQ *_rt_named_msgq_init(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> msgq_name, <span class="keywordtype">int</span> nmsg, <span class="keywordtype">int</span> size);
00091 <span class="keyword">static</span> <span class="keyword">inline</span> RT_MSGQ *rt_named_msgq_init(<span class="keyword">const</span> <span class="keywordtype">char</span> *msgq_name, <span class="keywordtype">int</span> nmsg, <span class="keywordtype">int</span> size)
00092 {
00093         <span class="keywordflow">return</span> _rt_named_msgq_init(<a class="code" href="rtai__nam2num_8h.html#a0">nam2num</a>(msgq_name), nmsg, size);
00094 }
00095 
00096 <span class="keywordtype">int</span> rt_named_msgq_delete(RT_MSGQ *msgq);
00097 
00098 <span class="keywordtype">int</span> _rt_msg_send(RT_MSGQ *msgq, <span class="keywordtype">void</span> *msg, <span class="keywordtype">int</span> msg_size, <span class="keywordtype">int</span> msgpri, <span class="keywordtype">int</span> space);
00099 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">int</span> rt_msg_send(RT_MSGQ *msgq, <span class="keywordtype">void</span> *msg, <span class="keywordtype">int</span> msg_size, <span class="keywordtype">int</span> msgpri)
00100 {
00101         <span class="keywordflow">return</span> _rt_msg_send(msgq, msg, msg_size, msgpri, 1);
00102 }
00103 
00104 <span class="keywordtype">int</span> _rt_msg_send_if(RT_MSGQ *msgq, <span class="keywordtype">void</span> *msg, <span class="keywordtype">int</span> msg_size, <span class="keywordtype">int</span> msgpri, <span class="keywordtype">int</span> space);
00105 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">int</span> rt_msg_send_if(RT_MSGQ *msgq, <span class="keywordtype">void</span> *msg, <span class="keywordtype">int</span> msg_size, <span class="keywordtype">int</span> msgpri)
00106 {
00107         <span class="keywordflow">return</span> _rt_msg_send_if(msgq, msg, msg_size, msgpri, 1);
00108 }
00109 
00110 <span class="keywordtype">int</span> _rt_msg_send_until(RT_MSGQ *msgq, <span class="keywordtype">void</span> *msg, <span class="keywordtype">int</span> msg_size, <span class="keywordtype">int</span> msgpri, RTIME until, <span class="keywordtype">int</span> space);
00111 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">int</span> rt_msg_send_until(RT_MSGQ *msgq, <span class="keywordtype">void</span> *msg, <span class="keywordtype">int</span> msg_size, <span class="keywordtype">int</span> msgpri, RTIME until)
00112 {
00113         <span class="keywordflow">return</span> _rt_msg_send_until(msgq, msg, msg_size, msgpri, until, 1);
00114 }
00115 
00116 <span class="keywordtype">int</span> _rt_msg_send_timed(RT_MSGQ *msgq, <span class="keywordtype">void</span> *msg, <span class="keywordtype">int</span> msg_size, <span class="keywordtype">int</span> msgpri, RTIME delay, <span class="keywordtype">int</span> space);
00117 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">int</span> rt_msg_send_timed(RT_MSGQ *msgq, <span class="keywordtype">void</span> *msg, <span class="keywordtype">int</span> msg_size, <span class="keywordtype">int</span> msgpri, RTIME delay)
00118 {
00119         <span class="keywordflow">return</span> _rt_msg_send_timed(msgq, msg, msg_size, msgpri, delay, 1);
00120 }
00121 
00122 <span class="keywordtype">int</span> _rt_msg_receive(RT_MSGQ *msgq, <span class="keywordtype">void</span> *msg, <span class="keywordtype">int</span> msg_size, <span class="keywordtype">int</span> *msgpri, <span class="keywordtype">int</span> space);
00123 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">int</span> rt_msg_receive(RT_MSGQ *msgq, <span class="keywordtype">void</span> *msg, <span class="keywordtype">int</span> msg_size, <span class="keywordtype">int</span> *msgpri)
00124 {
00125         <span class="keywordflow">return</span> _rt_msg_receive(msgq, msg, msg_size, msgpri, 1);
00126 }
00127 
00128 <span class="keywordtype">int</span> _rt_msg_receive_if(RT_MSGQ *msgq, <span class="keywordtype">void</span> *msg, <span class="keywordtype">int</span> msg_size, <span class="keywordtype">int</span> *msgpri, <span class="keywordtype">int</span> space);
00129 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">int</span> rt_msg_receive_if(RT_MSGQ *msgq, <span class="keywordtype">void</span> *msg, <span class="keywordtype">int</span> msg_size, <span class="keywordtype">int</span> *msgpri)
00130 {
00131         <span class="keywordflow">return</span> _rt_msg_receive_if(msgq, msg, msg_size, msgpri, 1);
00132 }
00133 
00134 <span class="keywordtype">int</span> _rt_msg_receive_until(RT_MSGQ *msgq, <span class="keywordtype">void</span> *msg, <span class="keywordtype">int</span> msg_size, <span class="keywordtype">int</span> *msgpri, RTIME until, <span class="keywordtype">int</span> space);
00135 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">int</span> rt_msg_receive_until(RT_MSGQ *msgq, <span class="keywordtype">void</span> *msg, <span class="keywordtype">int</span> msg_size, <span class="keywordtype">int</span> *msgpri, RTIME until)
00136 {
00137         <span class="keywordflow">return</span> _rt_msg_receive_until(msgq, msg, msg_size, msgpri, until, 1);
00138 }
00139 
00140 <span class="keywordtype">int</span> _rt_msg_receive_timed(RT_MSGQ *msgq, <span class="keywordtype">void</span> *msg, <span class="keywordtype">int</span> msg_size, <span class="keywordtype">int</span> *msgpri, RTIME delay, <span class="keywordtype">int</span> space);
00141 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">int</span> rt_msg_receive_timed(RT_MSGQ *msgq, <span class="keywordtype">void</span> *msg, <span class="keywordtype">int</span> msg_size, <span class="keywordtype">int</span> *msgpri, RTIME delay)
00142 {
00143         <span class="keywordflow">return</span> _rt_msg_receive_timed(msgq, msg, msg_size, msgpri, delay, 1);
00144 }
00145 
00146 <span class="keywordtype">int</span> _rt_msg_evdrp(RT_MSGQ *msgq, <span class="keywordtype">void</span> *msg, <span class="keywordtype">int</span> msg_size, <span class="keywordtype">int</span> *msgpri, <span class="keywordtype">int</span> space);
00147 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">int</span> rt_msg_evdrp(RT_MSGQ *msgq, <span class="keywordtype">void</span> *msg, <span class="keywordtype">int</span> msg_size, <span class="keywordtype">int</span> *msgpri)
00148 {
00149         <span class="keywordflow">return</span> _rt_msg_evdrp(msgq, msg, msg_size, msgpri, 1);
00150 }
00151 
00152 <span class="keywordtype">int</span> _rt_msg_broadcast(RT_MSGQ *msgq, <span class="keywordtype">void</span> *msg, <span class="keywordtype">int</span> msg_size, <span class="keywordtype">int</span> msgpri, <span class="keywordtype">int</span> space);
00153 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">int</span> rt_msg_broadcast(RT_MSGQ *msgq, <span class="keywordtype">void</span> *msg, <span class="keywordtype">int</span> msg_size, <span class="keywordtype">int</span> msgpri)
00154 {
00155         <span class="keywordflow">return</span> _rt_msg_broadcast(msgq, msg, msg_size, msgpri, 1);
00156 }
00157 
00158 <span class="keywordtype">int</span> _rt_msg_broadcast_if(RT_MSGQ *msgq, <span class="keywordtype">void</span> *msg, <span class="keywordtype">int</span> msg_size, <span class="keywordtype">int</span> msgpri, <span class="keywordtype">int</span> space);
00159 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">int</span> rt_msg_broadcast_if(RT_MSGQ *msgq, <span class="keywordtype">void</span> *msg, <span class="keywordtype">int</span> msg_size, <span class="keywordtype">int</span> msgpri)
00160 {
00161         <span class="keywordflow">return</span> _rt_msg_broadcast_if(msgq, msg, msg_size, msgpri, 1);
00162 }
00163 
00164 <span class="keywordtype">int</span> _rt_msg_broadcast_until(RT_MSGQ *msgq, <span class="keywordtype">void</span> *msg, <span class="keywordtype">int</span> msg_size, <span class="keywordtype">int</span> msgpri, RTIME until, <span class="keywordtype">int</span> space);
00165 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">int</span> rt_msg_broadcast_until(RT_MSGQ *msgq, <span class="keywordtype">void</span> *msg, <span class="keywordtype">int</span> msg_size, <span class="keywordtype">int</span> msgpri, RTIME until)
00166 {
00167         <span class="keywordflow">return</span> _rt_msg_broadcast_until(msgq, msg, msg_size, msgpri, until, 1);
00168 }
00169 
00170 <span class="keywordtype">int</span> _rt_msg_broadcast_timed(RT_MSGQ *msgq, <span class="keywordtype">void</span> *msg, <span class="keywordtype">int</span> msg_size, <span class="keywordtype">int</span> msgpri, RTIME delay, <span class="keywordtype">int</span> space);
00171 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">int</span> rt_msg_broadcast_delay(RT_MSGQ *msgq, <span class="keywordtype">void</span> *msg, <span class="keywordtype">int</span> msg_size, <span class="keywordtype">int</span> msgpri, RTIME delay)
00172 {
00173         <span class="keywordflow">return</span> _rt_msg_broadcast_until(msgq, msg, msg_size, msgpri, delay, 1);
00174 }
00175 
00176 <span class="preprocessor">#ifdef __cplusplus</span>
00177 <span class="preprocessor"></span>}
00178 <span class="preprocessor">#endif </span><span class="comment">/* __cplusplus */</span>
00179 
00180 <span class="preprocessor">#else </span><span class="comment">/* !__KERNEL__ */</span>
00181 
00182 <span class="preprocessor">#include &lt;signal.h&gt;</span>
00183 <span class="preprocessor">#include &lt;<a class="code" href="rtai__lxrt_8h.html">rtai_lxrt.h</a>&gt;</span>
00184 
00185 <span class="keyword">struct </span>rt_msgh;
00186 
00187 <span class="preprocessor">#ifdef __cplusplus</span>
00188 <span class="preprocessor"></span><span class="keyword">extern</span> <span class="stringliteral">"C"</span> {
00189 <span class="preprocessor">#endif </span><span class="comment">/* __cplusplus */</span>
00190 
00191 <span class="keyword">typedef</span> <span class="keyword">struct </span>rt_msgq {
00192         <span class="keywordtype">int</span> dummy;
00193 } RT_MSGQ;
00194 
00195 RTAI_PROTO(RT_MSGQ *, rt_msgq_init, (<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> msgq, <span class="keywordtype">int</span> nmsg, <span class="keywordtype">int</span> msg_size))
00196 {
00197         <span class="keyword">struct </span>{ <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> msgq; <span class="keywordtype">int</span> nmsg; <span class="keywordtype">int</span> msg_size; } arg = { msgq, nmsg, msg_size };
00198         <span class="keywordflow">return</span> rtai_lxrt(BIDX, SIZARG, NAMED_MSGQ_INIT, &amp;arg).v[LOW];
00199 }
00200 
00201 RTAI_PROTO(<span class="keywordtype">int</span>, rt_msgq_delete, (RT_MSGQ *msgq))
00202 {
00203         <span class="keyword">struct </span>{ RT_MSGQ *msgq; } arg = { msgq };
00204         <span class="keywordflow">return</span> rtai_lxrt(BIDX, SIZARG, NAMED_MSGQ_DELETE, &amp;arg).i[LOW];
00205 }
00206 
00207 RTAI_PROTO(RT_MSGQ *, rt_named_msgq_init,(<span class="keyword">const</span> <span class="keywordtype">char</span> *name, <span class="keywordtype">int</span> nmsg, <span class="keywordtype">int</span> size))
00208 {
00209         <span class="keyword">struct </span>{ <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> name; <span class="keywordtype">int</span> nmsg, size; } arg = { <a class="code" href="rtai__nam2num_8h.html#a0">nam2num</a>(name), nmsg, size };
00210         <span class="keywordflow">return</span> rtai_lxrt(BIDX, SIZARG, NAMED_MSGQ_INIT, &amp;arg).v[LOW];
00211 }
00212 
00213 RTAI_PROTO(<span class="keywordtype">int</span>, rt_named_msgq_delete, (RT_MSGQ *msgq))
00214 {
00215         <span class="keyword">struct </span>{ RT_MSGQ *msgq; } arg = { msgq };
00216         <span class="keywordflow">return</span> rtai_lxrt(BIDX, SIZARG, NAMED_MSGQ_DELETE, &amp;arg).i[LOW];
00217 }
00218 
00219 RTAI_PROTO(<span class="keywordtype">int</span>, rt_msg_send, (RT_MSGQ *msgq, <span class="keywordtype">void</span> *msg, <span class="keywordtype">int</span> msg_size, <span class="keywordtype">int</span> msgprio))
00220 {
00221         <span class="keyword">struct </span>{ RT_MSGQ *msgq; <span class="keywordtype">void</span> *msg; <span class="keywordtype">int</span> msg_size; <span class="keywordtype">int</span> msgprio; <span class="keywordtype">int</span> space; } arg = { msgq, msg, msg_size, msgprio, 0 };
00222         <span class="keywordflow">return</span> rtai_lxrt(BIDX, SIZARG, MSG_SEND, &amp;arg).i[LOW];
00223 }
00224 
00225 RTAI_PROTO(<span class="keywordtype">int</span>, rt_msg_send_if, (RT_MSGQ *msgq, <span class="keywordtype">void</span> *msg, <span class="keywordtype">int</span> msg_size, <span class="keywordtype">int</span> msgprio))
00226 {
00227         <span class="keyword">struct </span>{ RT_MSGQ *msgq; <span class="keywordtype">void</span> *msg; <span class="keywordtype">int</span> msg_size; <span class="keywordtype">int</span> msgprio; <span class="keywordtype">int</span> space; } arg = { msgq, msg, msg_size, msgprio, 0 };
00228         <span class="keywordflow">return</span> rtai_lxrt(BIDX, SIZARG, MSG_SEND_IF, &amp;arg).i[LOW];
00229 }
00230 
00231 RTAI_PROTO(<span class="keywordtype">int</span>, rt_msg_send_until, (RT_MSGQ *msgq, <span class="keywordtype">void</span> *msg, <span class="keywordtype">int</span> msg_size, <span class="keywordtype">int</span> msgprio, RTIME until))
00232 {
00233         <span class="keyword">struct </span>{ RT_MSGQ *msgq; <span class="keywordtype">void</span> *msg; <span class="keywordtype">int</span> msg_size; <span class="keywordtype">int</span> msgprio; RTIME until; <span class="keywordtype">int</span> space; } arg = { msgq, msg, msg_size, msgprio, until, 0 };
00234         <span class="keywordflow">return</span> rtai_lxrt(BIDX, SIZARG, MSG_SEND_UNTIL, &amp;arg).i[LOW];
00235 }
00236 
00237 RTAI_PROTO(<span class="keywordtype">int</span>, rt_msg_send_timed, (RT_MSGQ *msgq, <span class="keywordtype">void</span> *msg, <span class="keywordtype">int</span> msg_size, <span class="keywordtype">int</span> msgprio, RTIME delay))
00238 {
00239         <span class="keyword">struct </span>{ RT_MSGQ *msgq; <span class="keywordtype">void</span> *msg; <span class="keywordtype">int</span> msg_size; <span class="keywordtype">int</span> msgprio; RTIME delay; <span class="keywordtype">int</span> space; } arg = { msgq, msg, msg_size, msgprio, delay, 0 };
00240         <span class="keywordflow">return</span> rtai_lxrt(BIDX, SIZARG, MSG_SEND_TIMED, &amp;arg).i[LOW];
00241 }
00242 
00243 RTAI_PROTO(<span class="keywordtype">int</span>, rt_msg_receive, (RT_MSGQ *msgq, <span class="keywordtype">void</span> *msg, <span class="keywordtype">int</span> msg_size, <span class="keywordtype">int</span> *msgprio))
00244 {
00245         <span class="keyword">struct </span>{ RT_MSGQ *msgq; <span class="keywordtype">void</span> *msg; <span class="keywordtype">int</span> msg_size; <span class="keywordtype">int</span> *msgprio; <span class="keywordtype">int</span> space; } arg = { msgq, msg, msg_size, msgprio, 0 };
00246         <span class="keywordflow">return</span> rtai_lxrt(BIDX, SIZARG, MSG_RECEIVE, &amp;arg).i[LOW];
00247 }
00248 
00249 RTAI_PROTO(<span class="keywordtype">int</span>, rt_msg_receive_if, (RT_MSGQ *msgq, <span class="keywordtype">void</span> *msg, <span class="keywordtype">int</span> msg_size, <span class="keywordtype">int</span> msgprio))
00250 {
00251         <span class="keyword">struct </span>{ RT_MSGQ *msgq; <span class="keywordtype">void</span> *msg; <span class="keywordtype">int</span> msg_size; <span class="keywordtype">int</span> msgprio; <span class="keywordtype">int</span> space; } arg = { msgq, msg, msg_size, msgprio, 0 };
00252         <span class="keywordflow">return</span> rtai_lxrt(BIDX, SIZARG, MSG_RECEIVE_IF, &amp;arg).i[LOW];
00253 }
00254 
00255 RTAI_PROTO(<span class="keywordtype">int</span>, rt_msg_receive_until, (RT_MSGQ *msgq, <span class="keywordtype">void</span> *msg, <span class="keywordtype">int</span> msg_size, <span class="keywordtype">int</span> msgprio, RTIME until))
00256 {
00257         <span class="keyword">struct </span>{ RT_MSGQ *msgq; <span class="keywordtype">void</span> *msg; <span class="keywordtype">int</span> msg_size; <span class="keywordtype">int</span> msgprio; RTIME until; <span class="keywordtype">int</span> space; } arg = { msgq, msg, msg_size, msgprio, until, 0 };
00258         <span class="keywordflow">return</span> rtai_lxrt(BIDX, SIZARG, MSG_RECEIVE_UNTIL, &amp;arg).i[LOW];
00259 }
00260 
00261 RTAI_PROTO(<span class="keywordtype">int</span>, rt_msg_receive_timed, (RT_MSGQ *msgq, <span class="keywordtype">void</span> *msg, <span class="keywordtype">int</span> msg_size, <span class="keywordtype">int</span> msgprio, RTIME delay))
00262 {
00263         <span class="keyword">struct </span>{ RT_MSGQ *msgq; <span class="keywordtype">void</span> *msg; <span class="keywordtype">int</span> msg_size; <span class="keywordtype">int</span> msgprio; RTIME delay; <span class="keywordtype">int</span> space; } arg = { msgq, msg, msg_size, msgprio, delay, 0 };
00264         <span class="keywordflow">return</span> rtai_lxrt(BIDX, SIZARG, MSG_RECEIVE_TIMED, &amp;arg).i[LOW];
00265 }
00266 
00267 RTAI_PROTO(<span class="keywordtype">int</span>, rt_msg_evdrp, (RT_MSGQ *msgq, <span class="keywordtype">void</span> *msg, <span class="keywordtype">int</span> msg_size, <span class="keywordtype">int</span> *msgprio))
00268 {
00269         <span class="keyword">struct </span>{ RT_MSGQ *msgq; <span class="keywordtype">void</span> *msg; <span class="keywordtype">int</span> msg_size; <span class="keywordtype">int</span> *msgprio; <span class="keywordtype">int</span> space; } arg = { msgq, msg, msg_size, msgprio, 0 };
00270         <span class="keywordflow">return</span> rtai_lxrt(BIDX, SIZARG, MSG_EVDRP, &amp;arg).i[LOW];
00271 }
00272 
00273 RTAI_PROTO(<span class="keywordtype">int</span>, rt_msg_broadcast, (RT_MSGQ *msgq, <span class="keywordtype">void</span> *msg, <span class="keywordtype">int</span> msg_size, <span class="keywordtype">int</span> msgprio))
00274 {
00275         <span class="keyword">struct </span>{ RT_MSGQ *msgq; <span class="keywordtype">void</span> *msg; <span class="keywordtype">int</span> msg_size; <span class="keywordtype">int</span> msgprio; <span class="keywordtype">int</span> space; } arg = { msgq, msg, msg_size, msgprio, 0 };
00276         <span class="keywordflow">return</span> rtai_lxrt(BIDX, SIZARG, MSG_BROADCAST, &amp;arg).i[LOW];
00277 }
00278 
00279 RTAI_PROTO(<span class="keywordtype">int</span>, rt_msg_broadcast_if, (RT_MSGQ *msgq, <span class="keywordtype">void</span> *msg, <span class="keywordtype">int</span> msg_size, <span class="keywordtype">int</span> msgprio))
00280 {
00281         <span class="keyword">struct </span>{ RT_MSGQ *msgq; <span class="keywordtype">void</span> *msg; <span class="keywordtype">int</span> msg_size; <span class="keywordtype">int</span> msgprio; <span class="keywordtype">int</span> space; } arg = { msgq, msg, msg_size, msgprio, 0 };
00282         <span class="keywordflow">return</span> rtai_lxrt(BIDX, SIZARG, MSG_BROADCAST_IF, &amp;arg).i[LOW];
00283 }
00284 
00285 RTAI_PROTO(<span class="keywordtype">int</span>, rt_msg_broadcast_until, (RT_MSGQ *msgq, <span class="keywordtype">void</span> *msg, <span class="keywordtype">int</span> msg_size, <span class="keywordtype">int</span> msgprio, RTIME until))
00286 {
00287         <span class="keyword">struct </span>{ RT_MSGQ *msgq; <span class="keywordtype">void</span> *msg; <span class="keywordtype">int</span> msg_size; <span class="keywordtype">int</span> msgprio; RTIME until; <span class="keywordtype">int</span> space; } arg = { msgq, msg, msg_size, msgprio, until, 0 };
00288         <span class="keywordflow">return</span> rtai_lxrt(BIDX, SIZARG, MSG_BROADCAST_UNTIL, &amp;arg).i[LOW];
00289 }
00290 
00291 RTAI_PROTO(<span class="keywordtype">int</span>, rt_msg_broadcast_timed, (RT_MSGQ *msgq, <span class="keywordtype">void</span> *msg, <span class="keywordtype">int</span> msg_size, <span class="keywordtype">int</span> msgprio, RTIME delay))
00292 {
00293         <span class="keyword">struct </span>{ RT_MSGQ *msgq; <span class="keywordtype">void</span> *msg; <span class="keywordtype">int</span> msg_size; <span class="keywordtype">int</span> msgprio; RTIME delay; <span class="keywordtype">int</span> space; } arg = { msgq, msg, msg_size, msgprio, delay, 0 };
00294         <span class="keywordflow">return</span> rtai_lxrt(BIDX, SIZARG, MSG_BROADCAST_TIMED, &amp;arg).i[LOW];
00295 }
00296 
00297 <span class="preprocessor">#ifdef __cplusplus</span>
00298 <span class="preprocessor"></span>}
00299 <span class="preprocessor">#endif </span><span class="comment">/* __cplusplus */</span>
00300 
00301 <span class="preprocessor">#endif </span><span class="comment">/* __KERNEL__ */</span>
00302 
00303 <span class="preprocessor">#define rt_tbx_init(tbx, size, flags)  rt_msgq_init(tbx, size, 0)</span>
00304 <span class="preprocessor"></span><span class="preprocessor">#define rt_tbx_delete(tbx)             rt_msgq_delete(tbx)</span>
00305 <span class="preprocessor"></span>
00306 <span class="preprocessor">#define rt_tbx_send(tbx, msg, msg_size)               rt_msg_send(tbx, msg, msg_size, 1)</span>
00307 <span class="preprocessor"></span><span class="preprocessor">#define rt_tbx_send_if(tbx, msg, msg_size)            rt_msg_send_if(tbx, msg, msg_size, 1)</span>
00308 <span class="preprocessor"></span><span class="preprocessor">#define rt_tbx_send_until(tbx, msg, msg_size, until)  rt_msg_send_until(tbx, msg, msg_size, 1, until)</span>
00309 <span class="preprocessor"></span><span class="preprocessor">#define rt_tbx_send_timed(tbx, msg, msg_size, delay)  rt_msg_send_timed(tbx, msg, msg_size, 1, delay)</span>
00310 <span class="preprocessor"></span>
00311 <span class="preprocessor">#define rt_tbx_receive(tbx, msg, msg_size)               rt_msg_receive(tbx, msg, msg_size, 0)</span>
00312 <span class="preprocessor"></span><span class="preprocessor">#define rt_tbx_receive_if(tbx, msg, msg_size)            rt_msg_receive_if(tbx, msg, msg_size, 0)</span>
00313 <span class="preprocessor"></span><span class="preprocessor">#define rt_tbx_receive_until(tbx, msg, msg_size, until)  rt_msg_receive_until(tbx, msg, msg_size, 0, until)</span>
00314 <span class="preprocessor"></span><span class="preprocessor">#define rt_tbx_receive_timed(tbx, msg, msg_size, delay)  rt_msg_receive_timed(tbx, msg, msg_size, 0, delay)</span>
00315 <span class="preprocessor"></span>
00316 <span class="preprocessor">#define rt_tbx_broadcast(tbx, msg, msg_size)               rt_msg_broadcast(tbx, msg, msg_size, 0)</span>
00317 <span class="preprocessor"></span><span class="preprocessor">#define rt_tbx_broadcast_if(tbx, msg, msg_size)            rt_msg_broadcast_if(tbx, msg, msg_size, 0)</span>
00318 <span class="preprocessor"></span><span class="preprocessor">#define rt_tbx_broadcast_until(tbx, msg, msg_size, until)  rt_msg_broadcast_until(tbx, msg, msg_size, 0, until)</span>
00319 <span class="preprocessor"></span><span class="preprocessor">#define rt_tbx_broadcast_timed(tbx, msg, msg_size, delay)  rt_msg_broadcast_timed(tbx, msg, msg_size, 0, delay)</span>
00320 <span class="preprocessor"></span>
00321 <span class="preprocessor">#define rt_tbx_urgent(tbx, msg, msg_size)               rt_msg_send(tbx, msg, msg_size, 0)</span>
00322 <span class="preprocessor"></span><span class="preprocessor">#define rt_tbx_urgent_if(tbx, msg, msg_size)            rt_msg_send_if(tbx, msg, msg_size, 0)</span>
00323 <span class="preprocessor"></span><span class="preprocessor">#define rt_tbx_urgent_until(tbx, msg, msg_size, until)  rt_msg_send_until(tbx, msg, msg_size, 0, until)</span>
00324 <span class="preprocessor"></span><span class="preprocessor">#define rt_tbx_urgent_timed(tbx, msg, msg_size, delay)  rt_msg_send_timed(tbx, msg, msg_size, 0, delay)</span>
00325 <span class="preprocessor"></span>
00326 <span class="preprocessor">#endif  </span><span class="comment">/* !_RTAI_RT_MSGQ_H */</span>
</pre></div><hr size="1"><address style="align: right;"><small>Generated on Thu Nov 17 12:29:19 2005 for RTAI API by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.4.2 </small></address>
</body>
</html>
